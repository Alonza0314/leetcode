{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"LeetCode Problem Solutions","text":"<p>Note</p> <p>This website contains my LeetCode problem solving records, problems are categorized by difficulty:</p> <ul> <li>Easy - Easy difficulty problems</li> <li>Medium - Medium difficulty problems</li> <li>Hard - Hard difficulty problems</li> </ul>"},{"location":"#solution-table","title":"Solution Table","text":"Number Title Solution Difficulty 1 Two Sum go E 2 Add Two Numbers go M 3 Longest Substring Without Repeating Characters go M 4 Median of Two Sorted Arrays go H 5 Longest Palindromic Substring go M 6 Zigzag Conversion go M 7 Reverse Integer go M 8 String to Integer (atoi) go M 9 Palindrome Number go E 10 Regular Expression Matching go H 11 Container With Most Water go M 12 Integer to Roman go M 13 Roman to Integer go E 14 Longest Common Prefix go E 15 3Sum go M 16 3Sum Closest go M 17 Letter Combinations of a Phone Number go M 23 Merge k Sorted Lists go H 24 Swap Nodes in Pairs go M 25 Reverse Nodes in k-Group go H 38 Count and Say go M 42 Trapping Rain Water go H 44 Wildcard Matching go H 45 Jump Game II go M 46 Permutations go M 50 Pow(x, n) go M 51 N-Queens go H 73 Set Matrix Zeroes go M 105 Construct Binary Tree from Preorder and Inorder Tranversal go M 124 Binary Tree Maximum Path Sum go H 135 Candy go H 140 Word Break II go H 146 LRU Cache go M 210 Course Schedule II go M 220 Contains Duplicate III go H 236 Lowest Common Ancestor of a Binary Tree go M 239 Sliding Window Maximum go H 312 Burst Balloons go H 316 Remove Duplicate Letters go M 322 Coin Change go M 347 Top K Frequent Elements go M 386 Lexicographical Numbers go M 416 Partition Equal Subset Sum go M 435 Non-overlapping Interval go M 440 K-th Smallest in Lexicographical Order go H 460 LFU Cache go H 592 Fraction Addition and Subtraction go M 594 Longest Harmonious Subsequence go E 685 Redundant Connection II go H 752 Open the Lock go M 757 Set Intersection Size At Least Two go H 765 Couples Holding Hands go H 815 Bus Routes go H 834 Sum of Distances in Tree go H 840 Magic Squares In Grid go M 847 Shortest Path Visiting All Nodes go H 855 Exam Room go M 875 Koko Eating Bananas go M 881 Boats to Save People go M 887 Super Egg Drop go H 895 Maximum Frequency Stack go H 912 Sort an Array go M 948 Bag of Tokens go M 1209 Remove All Adjacent Duplicates in String II go M 1395 Count Number of Trams go M 2016 Maximum Difference Between Increasing Elements go E 2071 Maximum Number of Tasks You Can Assign go H 2099 Find Subsequence of Length K With the Largest Sum go E 2138 Divide a String Into Groups of Size k go E 2294 Partition Array Such That Maximum Difference Is K go M 2366 Mimimum Replacements to Sort the Array go H 2392 Build A Matrix with Conditions go H 2444 Count Subarrays With Fixed Bounds go H 2742 Paiting the Walls go H 2894 Divisible and Non-divisible Sums Difference go E 2966 Divide Array Into Arrays With Max Difference go M 3024 Type of Triangle go E 3355 Zero Array Transformation I go M 3362 Zero Array Transformation III go M 3372 Maximize the Number of Target Nodes After Connecting Trees I go M 3373 Maximize the Number of Target Nodes After Connecting Trees II go H 3423 Maximum Difference Between Adjacent Elements in a Circular Array go E 3442 Maximum Difference Between Even and Odd Frequency I go E 3443 Maximum Manhattan Distance After K Changes go M 3727 Find the Count of Good Integers go H"},{"location":"#about","title":"About","text":"<p>This website is built with MkDocs and hosted on GitHub Pages. All solution code can be found in the Repository: alonza0314/leetcode.</p>"},{"location":"Easy/1%20Two%20Sum/","title":"1. Two Sum","text":""},{"location":"Easy/1%20Two%20Sum/#intuition","title":"Intuition","text":"<p>The problem requires finding two numbers in an array that add up to a target value. A straightforward approach would be using two nested loops to check every possible pair, but that would be inefficient. Instead, we can use a hash map to store previously seen numbers and their indices, which allows us to find complements in constant time.</p>"},{"location":"Easy/1%20Two%20Sum/#approach","title":"Approach","text":"<ol> <li>Create a hash map to store numbers and their indices</li> <li>Iterate through the array once</li> <li>For each number:<ul> <li>Calculate the complement (target - current number)</li> <li>Check if the complement exists in the hash map</li> <li>If found, return current index and the complement's index</li> <li>If not found, store current number and its index in the hash map</li> </ul> </li> <li>Continue until a solution is found</li> </ol>"},{"location":"Easy/1%20Two%20Sum/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(n)</li> <li>Space complexity: O(n)</li> </ul>"},{"location":"Easy/1%20Two%20Sum/#keywords","title":"Keywords","text":"<ul> <li>Hash Map</li> </ul>"},{"location":"Easy/1%20Two%20Sum/#code","title":"Code","text":"<pre><code>func twoSum(nums []int, target int) []int {\n    ans := make([]int, 2, 2)\n    tmp_map := make(map[int]int)\n    size := len(nums)\n    for i := 0; i &lt; size; i++ {\n        tmp := target-nums[i]\n        if _, ok := tmp_map[tmp]; ok {\n            ans[0] = i\n            ans[1] = tmp_map[tmp]\n            return ans\n        }\n        tmp_map[nums[i]] = i\n    }\n    return ans\n}\n</code></pre>"},{"location":"Easy/13%20Roman%20to%20Integer/","title":"13. Roman to Integer","text":""},{"location":"Easy/13%20Roman%20to%20Integer/#intuition","title":"Intuition","text":"<p>The key insight is that Roman numerals are typically written from largest to smallest value, but there are special cases where a smaller value precedes a larger value (like IV for 4). In these cases, we need to subtract the smaller value from the larger one.</p>"},{"location":"Easy/13%20Roman%20to%20Integer/#approach","title":"Approach","text":"<ol> <li>Create a mapping of Roman numerals to their integer values</li> <li>Start from the end of the string and work backwards</li> <li>For each character:<ul> <li>If the current value is less than the next value, subtract it from the result</li> <li>Otherwise, add it to the result</li> </ul> </li> <li>Return the final result</li> </ol>"},{"location":"Easy/13%20Roman%20to%20Integer/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(n)</li> <li>Space complexity: O(1)</li> </ul>"},{"location":"Easy/13%20Roman%20to%20Integer/#keywords","title":"Keywords","text":"<ul> <li>Hash Map</li> <li>String</li> <li>Math</li> </ul>"},{"location":"Easy/13%20Roman%20to%20Integer/#code","title":"Code","text":"<pre><code>func romanToInt(s string) int {\n    mp := map[byte]int {\n        'I': 1,\n        'V': 5,\n        'X': 10,\n        'L': 50,\n        'C': 100,\n        'D': 500,\n        'M': 1000,\n    }\n    ret := mp[s[len(s) - 1]]\n    for i := len(s) - 2; i &gt;= 0; i-- {\n        if mp[s[i]] &lt; mp[s[i + 1]] {\n            ret -= mp[s[i]]\n        } else {\n            ret += mp[s[i]]\n        }\n    }\n    return ret\n}\n</code></pre>"},{"location":"Easy/14%20Longest%20Common%20Prefix/","title":"14. Longest Common Prefix","text":""},{"location":"Easy/14%20Longest%20Common%20Prefix/#intuition","title":"Intuition","text":"<p>The longest common prefix of all strings must be a prefix of the shortest string in the array. We can compare characters at each position across all strings until we find a mismatch or reach the end of the shortest string.</p>"},{"location":"Easy/14%20Longest%20Common%20Prefix/#approach","title":"Approach","text":"<ol> <li>First, find the length of the shortest string in the array using a helper function <code>Min</code></li> <li>Iterate through each character position up to the length of the shortest string</li> <li>For each position, compare the character with the corresponding character in the first string</li> <li>If any string has a different character at that position, return the prefix up to that position</li> <li>If we complete the iteration without finding any mismatches, return the entire shortest string as the common prefix</li> </ol>"},{"location":"Easy/14%20Longest%20Common%20Prefix/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(n)</li> <li>Space complexity: O(1)</li> </ul>"},{"location":"Easy/14%20Longest%20Common%20Prefix/#keywords","title":"Keywords","text":"<ul> <li>String</li> <li>Prefix</li> </ul>"},{"location":"Easy/14%20Longest%20Common%20Prefix/#code","title":"Code","text":"<pre><code>func Min(strs []string) int {\n    ret := math.MaxInt\n    for _, str := range strs {\n        if len(str) &lt; ret {\n            ret = len(str)\n        }\n    }\n    return ret\n}\nfunc longestCommonPrefix(strs []string) string {\n    min := Min(strs)\n    for i := 0; i &lt; min ; i++ {\n        flag := strs[0][i]\n        for _, str := range strs {\n            if str[i] != flag {\n                return string(strs[0][:i])\n            }\n        }\n    }\n    return string(strs[0][:min])\n}\n</code></pre>"},{"location":"Easy/2016%20Maximum%20Difference%20Between%20Increasing%20Elements/","title":"2016. Maximum Difference Between Increasing Elements","text":""},{"location":"Easy/2016%20Maximum%20Difference%20Between%20Increasing%20Elements/#intuition","title":"Intuition","text":"<p>The problem asks for the maximum difference between two elements in the array such that the larger element comes after the smaller one. The intuition is to keep track of the minimum value seen so far and, for each element, calculate the difference if it is greater than the minimum.</p>"},{"location":"Easy/2016%20Maximum%20Difference%20Between%20Increasing%20Elements/#approach","title":"Approach","text":"<p>We iterate through the array while maintaining the minimum value encountered so far. For each element, if it is greater than the minimum, we compute the difference and update the result if this difference is larger than the current result. If the current element is smaller than the minimum, we update the minimum. If no such pair exists, we return -1.</p>"},{"location":"Easy/2016%20Maximum%20Difference%20Between%20Increasing%20Elements/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(n)</li> <li>Space complexity: O(1)</li> </ul>"},{"location":"Easy/2016%20Maximum%20Difference%20Between%20Increasing%20Elements/#keywords","title":"Keywords","text":"<ul> <li>Minimum Tracking</li> <li>Greedy</li> </ul>"},{"location":"Easy/2016%20Maximum%20Difference%20Between%20Increasing%20Elements/#code","title":"Code","text":"<pre><code>func maximumDifference(nums []int) int {\n    m, ret := nums[0], -1\n    for i := 1; i &lt; len(nums); i += 1 {\n        if nums[i] &gt; m {\n            ret = max(ret, nums[i] - m)\n        } else if nums[i] &lt; m {\n            m = nums[i]\n        }\n    }\n    return ret\n}\n</code></pre>"},{"location":"Easy/2099%20Find%20Subsequence%20of%20Length%20K%20With%20the%20Largest%20Sum/","title":"2099. Find Subsequence of Length K With the Largest Sum","text":""},{"location":"Easy/2099%20Find%20Subsequence%20of%20Length%20K%20With%20the%20Largest%20Sum/#intuition","title":"Intuition","text":"<p>To find a subsequence with the largest sum and length k, we need to select the k largest numbers from the array while maintaining their relative order in the original array. This suggests we need both sorting and index tracking.</p>"},{"location":"Easy/2099%20Find%20Subsequence%20of%20Length%20K%20With%20the%20Largest%20Sum/#approach","title":"Approach","text":"<ol> <li>Create a structure to store both the number and its original index</li> <li>Convert the input array into an array of this structure</li> <li>Sort the array based on the numbers in ascending order</li> <li>Take the last k elements (largest numbers)</li> <li>Sort these k elements based on their original indices to maintain the relative order</li> <li>Extract just the numbers from the sorted result</li> </ol>"},{"location":"Easy/2099%20Find%20Subsequence%20of%20Length%20K%20With%20the%20Largest%20Sum/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(nlogn)</li> <li>Space complexity: O(n)</li> </ul>"},{"location":"Easy/2099%20Find%20Subsequence%20of%20Length%20K%20With%20the%20Largest%20Sum/#keywords","title":"Keywords","text":"<ul> <li>Sorting</li> <li>Index tracking</li> <li>Subsequence</li> </ul>"},{"location":"Easy/2099%20Find%20Subsequence%20of%20Length%20K%20With%20the%20Largest%20Sum/#code","title":"Code","text":"<pre><code>func maxSubsequence(nums []int, k int) []int {\n    type unit struct {\n        n int\n        i int\n    }\n    ns := make([]unit, len(nums))\n    for i, n := range nums {\n        ns[i].n = n\n        ns[i].i = i\n    }\n    sort.Slice(ns, func(i, j int) bool {\n        return ns[i].n &lt; ns[j].n\n    })\n\n    tgtNs := ns[len(nums) - k:]\n    sort.Slice(tgtNs, func(i, j int) bool {\n        return tgtNs[i].i &lt; tgtNs[j].i\n    })\n    ret := make([]int, len(tgtNs))\n    for i, u := range tgtNs {\n        ret[i] = u.n\n    }\n\n    return ret\n}\n</code></pre>"},{"location":"Easy/2138%20Divide%20a%20String%20Into%20Groups%20of%20Size%20k/","title":"2138. Divide a String Into Groups of Size k","text":""},{"location":"Easy/2138%20Divide%20a%20String%20Into%20Groups%20of%20Size%20k/#intuition","title":"Intuition","text":"<p>The problem requires dividing a string into groups of size k. If the last group has fewer characters than k, we need to fill it with the given fill character until it reaches size k. This suggests using a loop to process the string in chunks of k characters.</p>"},{"location":"Easy/2138%20Divide%20a%20String%20Into%20Groups%20of%20Size%20k/#approach","title":"Approach","text":"<ol> <li>Create an empty slice to store the resulting strings</li> <li>Iterate through the string with steps of k characters</li> <li>For each iteration:<ul> <li>If there are at least k characters remaining, take a substring of k characters</li> <li>If there are fewer than k characters remaining:<ul> <li>Take the remaining characters</li> <li>Fill the rest with the given fill character until reaching length k</li> </ul> </li> </ul> </li> <li>Return the resulting slice of strings</li> </ol>"},{"location":"Easy/2138%20Divide%20a%20String%20Into%20Groups%20of%20Size%20k/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(n)</li> <li>Space complexity: O(n)</li> </ul>"},{"location":"Easy/2138%20Divide%20a%20String%20Into%20Groups%20of%20Size%20k/#keywords","title":"Keywords","text":"<ul> <li>String Manipulation</li> <li>String Padding</li> </ul>"},{"location":"Easy/2138%20Divide%20a%20String%20Into%20Groups%20of%20Size%20k/#code","title":"Code","text":"<pre><code>func divideString(s string, k int, fill byte) []string {\n    ret := make([]string, 0)\n    for i := 0; i &lt; len(s); i += k {\n        if i + k &lt; len(s) {\n            ret = append(ret, string(s[i: i + k]))\n        } else {\n            ret = append(ret, string(s[i:]))\n            for j := len(ret[len(ret) - 1]); j &lt; k; j += 1 {\n                ret[len(ret) - 1] += string(fill)\n            } \n        }\n    }\n    return ret\n}\n</code></pre>"},{"location":"Easy/2894%20Divisible%20and%20Non-divisible%20Sums%20Difference/","title":"2894. Divisible and Non-divisible Sums Difference","text":""},{"location":"Easy/2894%20Divisible%20and%20Non-divisible%20Sums%20Difference/#intuition","title":"Intuition","text":"<p>The problem requires us to find the difference between two sums:</p> <ol> <li>Sum of numbers from 1 to n that are NOT divisible by m</li> <li>Sum of numbers from 1 to n that are divisible by m</li> </ol> <p>We can solve this by iterating through numbers 1 to n and checking if each number is divisible by m using the modulo operator.</p>"},{"location":"Easy/2894%20Divisible%20and%20Non-divisible%20Sums%20Difference/#approach","title":"Approach","text":"<ol> <li>Initialize two variables:<ul> <li><code>nd</code> for sum of non-divisible numbers</li> <li><code>d</code> for sum of divisible numbers</li> </ul> </li> <li>Iterate through numbers from 1 to n</li> <li>For each number i:<ul> <li>If i is divisible by m (i % m == 0), add it to d</li> <li>If i is not divisible by m, add it to nd</li> </ul> </li> <li>Return the difference (nd - d)</li> </ol>"},{"location":"Easy/2894%20Divisible%20and%20Non-divisible%20Sums%20Difference/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(n)</li> <li>Space complexity: O(1)</li> </ul>"},{"location":"Easy/2894%20Divisible%20and%20Non-divisible%20Sums%20Difference/#keywords","title":"Keywords","text":"<ul> <li>Math</li> <li>Modulo Operation</li> </ul>"},{"location":"Easy/2894%20Divisible%20and%20Non-divisible%20Sums%20Difference/#code","title":"Code","text":"<pre><code>func differenceOfSums(n int, m int) int {\n    nd, d := 0, 0\n    for i := 1; i &lt;= n; i += 1 {\n        if i % m == 0 {\n            d += i\n        } else {\n            nd += i\n        }\n    }\n    return nd - d\n}\n</code></pre>"},{"location":"Easy/3024%20Type%20of%20Triangle/","title":"3024. Type of Triangle","text":""},{"location":"Easy/3024%20Type%20of%20Triangle/#intuition","title":"Intuition","text":"<p>To determine the type of triangle, we need to:</p> <ol> <li>Check if the three sides can form a valid triangle</li> <li>Count the number of equal sides to determine the triangle type</li> <li>Return the appropriate triangle type based on the conditions</li> </ol>"},{"location":"Easy/3024%20Type%20of%20Triangle/#approach","title":"Approach","text":"<ol> <li> <p>First define constant strings for different triangle types:</p> <ul> <li>equilateral: all sides equal</li> <li>isosceles: two sides equal</li> <li>scalene: no sides equal</li> <li>none: not a valid triangle</li> </ul> </li> <li> <p>Create a helper function <code>checkTriangle</code> to verify if three sides can form a valid triangle using the triangle inequality theorem:</p> <ul> <li>sum of any two sides must be greater than the third side</li> <li>check all three combinations: a+b&gt;c, b+c&gt;a, c+a&gt;b</li> </ul> </li> <li> <p>Use a map to count the frequency of each side length:</p> <ul> <li>If any number appears 3 times, it's an equilateral triangle</li> <li>If any number appears 2 times, it's potentially an isosceles triangle</li> <li>Otherwise, it's potentially a scalene triangle</li> </ul> </li> <li> <p>For isosceles and scalene cases, verify if they can form a valid triangle using <code>checkTriangle</code></p> </li> </ol>"},{"location":"Easy/3024%20Type%20of%20Triangle/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(1)</li> <li>Space complexity: O(1)</li> </ul>"},{"location":"Easy/3024%20Type%20of%20Triangle/#keywords","title":"Keywords","text":"<ul> <li>Triangle Inequality Theorem</li> <li>Hash Map</li> </ul>"},{"location":"Easy/3024%20Type%20of%20Triangle/#code","title":"Code","text":"<pre><code>func triangleType(nums []int) string {\n    var (\n        equ string = \"equilateral\"\n        iso string = \"isosceles\"\n        sca string = \"scalene\"\n        non string = \"none\"\n    )\n\n    checkTriangle := func() bool {\n        a, b, c := nums[0], nums[1], nums[2]\n        if (a + b &gt; c) &amp;&amp; (b + c &gt; a) &amp;&amp; (c + a &gt; b) {\n            return true\n        }\n        return false\n    }\n\n    record := make(map[int]int)\n    for _, num := range nums {\n        record[num] += 1\n        if record[num] == 3 {\n            return equ\n        }\n    }\n\n    for _, v := range record {\n        if v == 2 {\n            if checkTriangle() {\n                return iso\n            }\n            return non\n        }\n    }\n\n    if checkTriangle() {\n        return sca\n    }\n\n    return non\n}\n</code></pre>"},{"location":"Easy/3423%20Maximum%20Difference%20Between%20Adjacent%20Elements%20in%20a%20Circular%20Array/","title":"3423. Maximum Difference Between Adjacent Elements in a Circular Array","text":""},{"location":"Easy/3423%20Maximum%20Difference%20Between%20Adjacent%20Elements%20in%20a%20Circular%20Array/#intuition","title":"Intuition","text":"<p>The problem requires finding the maximum absolute difference between any two adjacent elements in a circular array. Since it's a circular array, we need to consider the difference between the first and last elements as they are also adjacent in a circular arrangement.</p>"},{"location":"Easy/3423%20Maximum%20Difference%20Between%20Adjacent%20Elements%20in%20a%20Circular%20Array/#approach","title":"Approach","text":"<ol> <li>Define a helper function <code>abs</code> to calculate the absolute value of a number</li> <li>Initialize the result variable <code>ret</code> with the minimum possible integer value</li> <li>Iterate through the array from index 0 to n-2:<ul> <li>Calculate the absolute difference between current element and next element</li> <li>Update the maximum difference if current difference is larger</li> </ul> </li> <li>Finally, check the difference between the last and first elements (circular connection)</li> <li>Return the maximum difference found</li> </ol>"},{"location":"Easy/3423%20Maximum%20Difference%20Between%20Adjacent%20Elements%20in%20a%20Circular%20Array/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(n)</li> <li>Space complexity: O(1)</li> </ul>"},{"location":"Easy/3423%20Maximum%20Difference%20Between%20Adjacent%20Elements%20in%20a%20Circular%20Array/#keywords","title":"Keywords","text":"<ul> <li>Circular Array</li> <li>Absolute Difference</li> <li>Math</li> </ul>"},{"location":"Easy/3423%20Maximum%20Difference%20Between%20Adjacent%20Elements%20in%20a%20Circular%20Array/#code","title":"Code","text":"<pre><code>func maxAdjacentDistance(nums []int) int {\n    abs := func(x int) int {\n        if x &lt; 0 {\n            return -x\n        }\n        return x\n    }\n\n    ret := math.MinInt\n    for i := 0; i &lt; len(nums) - 1; i += 1 {\n        ret = max(ret, abs(nums[i] - nums[i + 1]))\n    }\n\n    return max(ret, abs(nums[len(nums) - 1] - nums[0]))\n}\n</code></pre>"},{"location":"Easy/3442%20Maximum%20Difference%20Between%20Even%20and%20Odd%20Frequency%20I/","title":"3442. Maximum Difference Between Even and Odd Frequency I","text":""},{"location":"Easy/3442%20Maximum%20Difference%20Between%20Even%20and%20Odd%20Frequency%20I/#intuition","title":"Intuition","text":"<p>The problem requires us to find the maximum difference between odd and even frequencies of characters in a string. We can solve this by counting the frequency of each character and then finding the maximum odd frequency and minimum even frequency.</p>"},{"location":"Easy/3442%20Maximum%20Difference%20Between%20Even%20and%20Odd%20Frequency%20I/#approach","title":"Approach","text":"<ol> <li>Create a frequency array <code>record</code> of size 26 to store the count of each lowercase letter</li> <li>Count the frequency of each character in the string</li> <li>Iterate through the frequency array:<ul> <li>Skip if frequency is 0</li> <li>For odd frequencies, update the maximum odd frequency</li> <li>For even frequencies, update the minimum even frequency</li> </ul> </li> <li>Return the difference between maximum odd frequency and minimum even frequency</li> </ol>"},{"location":"Easy/3442%20Maximum%20Difference%20Between%20Even%20and%20Odd%20Frequency%20I/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(n)</li> <li>Space complexity: O(1)</li> </ul>"},{"location":"Easy/3442%20Maximum%20Difference%20Between%20Even%20and%20Odd%20Frequency%20I/#keywords","title":"Keywords","text":"<ul> <li>Frequency Count</li> <li>Array</li> <li>Maximum Difference</li> </ul>"},{"location":"Easy/3442%20Maximum%20Difference%20Between%20Even%20and%20Odd%20Frequency%20I/#code","title":"Code","text":"<pre><code>func maxDifference(s string) int {\n    record := make([]int, 26)\n\n    maxRecord, minRecord := math.MinInt, math.MaxInt\n    for _, c := range s {\n        record[c - 'a'] += 1\n    }\n\n    for _, v := range record {\n        if v == 0 {\n            continue\n        }\n        if v &amp; 1 == 1 {\n            maxRecord = max(maxRecord, v)\n        } else {\n            minRecord = min(minRecord, v)\n        }\n    }\n\n\n    return maxRecord - minRecord\n}\n</code></pre>"},{"location":"Easy/594%20Longest%20Harmonious%20Subsequence/","title":"594. Longest Harmonious Subsequence","text":""},{"location":"Easy/594%20Longest%20Harmonious%20Subsequence/#intuition","title":"Intuition","text":"<p>A harmonious subsequence is defined as a subsequence where the difference between the maximum and minimum values is exactly 1. To find the longest harmonious subsequence, we need to count the frequency of each number and then find pairs of adjacent numbers (differing by 1) that give us the maximum combined frequency.</p>"},{"location":"Easy/594%20Longest%20Harmonious%20Subsequence/#approach","title":"Approach","text":"<ol> <li> <p>Count Frequencies: Use a hash map to count the frequency of each number in the array.</p> </li> <li> <p>Extract and Sort Unique Numbers: Create a new array containing all unique numbers from the frequency map and sort it. This allows us to easily find adjacent numbers that differ by 1.</p> </li> <li> <p>Find Maximum Harmonious Length: Iterate through the sorted unique numbers and check consecutive pairs. If two adjacent numbers differ by exactly 1, calculate their combined frequency and update the maximum length.</p> </li> <li> <p>Return Result: The maximum combined frequency represents the length of the longest harmonious subsequence.</p> </li> </ol>"},{"location":"Easy/594%20Longest%20Harmonious%20Subsequence/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(n log k)</li> <li>Space complexity: O(k)</li> </ul>"},{"location":"Easy/594%20Longest%20Harmonious%20Subsequence/#keywords","title":"Keywords","text":"<ul> <li>Hash Map</li> <li>Frequency Counting</li> </ul>"},{"location":"Easy/594%20Longest%20Harmonious%20Subsequence/#code","title":"Code","text":"<pre><code>func findLHS(nums []int) int {\n    freq := make(map[int]int)\n    for _, num := range nums {\n        freq[num] += 1\n    }\n\n    nums, i := make([]int, len(freq)), 0\n    for k := range freq {\n        nums[i], i = k, i + 1\n    }\n    sort.Ints(nums)\n\n    ret := 0\n    for i := 0; i &lt; len(nums) - 1; i += 1 {\n        if nums[i + 1] - nums[i] != 1 {\n            continue\n        }\n        ret = max(ret, freq[nums[i]] + freq[nums[i + 1]])\n    }\n    return ret\n}\n</code></pre>"},{"location":"Easy/9%20Palindrome%20Number/","title":"9. Palindrome Number","text":""},{"location":"Easy/9%20Palindrome%20Number/#intuition","title":"Intuition","text":"<p>The intuition is to convert the number to a string and then check if it reads the same forwards and backwards. This is a straightforward approach that makes it easy to compare characters from both ends of the number.</p>"},{"location":"Easy/9%20Palindrome%20Number/#approach","title":"Approach","text":"<ol> <li>First, we handle the edge case where negative numbers cannot be palindromes</li> <li>Convert the number to a string using <code>strconv.Itoa()</code></li> <li>Convert the string to a rune slice to handle any potential Unicode characters</li> <li>Use two pointers (i and j) starting from both ends of the string</li> <li>Compare characters at both pointers and move them towards the center</li> <li>If any characters don't match, return false</li> <li>If all characters match, return true</li> </ol>"},{"location":"Easy/9%20Palindrome%20Number/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(n)</li> <li>Space complexity: O(n)</li> </ul>"},{"location":"Easy/9%20Palindrome%20Number/#keywords","title":"Keywords","text":"<ul> <li>Two Pointers</li> <li>String Conversion</li> <li>Palindrome</li> </ul>"},{"location":"Easy/9%20Palindrome%20Number/#code","title":"Code","text":"<pre><code>func isPalindrome(x int) bool {\n    if x &lt; 0 {\n        return false\n    }\n    xx := strconv.Itoa(x)\n    str := []rune(xx)\n\n    for i, j := 0, len(str) - 1; i &lt; j; i, j = i + 1, j - 1 {\n        if str[i] != str[j] {\n            return false\n        }\n    }\n    return true\n}\n</code></pre>"},{"location":"Hard/10%20Regular%20Expression%20Matching/","title":"10. Regular Expression Matching","text":""},{"location":"Hard/10%20Regular%20Expression%20Matching/#intuition","title":"Intuition","text":"<p>The problem requires us to implement a regular expression matcher that supports '.' and '*' patterns. The key insight is that we can use dynamic programming to solve this problem efficiently. We need to consider all possible matching scenarios, especially when dealing with the '*' pattern which can match zero or more of the preceding element.</p>"},{"location":"Hard/10%20Regular%20Expression%20Matching/#approach","title":"Approach","text":"<ol> <li>Create a 2D DP array where <code>dp[i][j]</code> represents whether the substring <code>s[i:]</code> matches the pattern <code>p[j:]</code></li> <li>Initialize the base case: <code>dp[n][m]</code> = true (empty string matches empty pattern)</li> <li>Process the string and pattern from right to left</li> <li>For each position, consider two cases:<ul> <li>If the next character is '*', we can either:<ul> <li>Skip the current pattern character and '*' (<code>dp[i][j+2]</code>)</li> <li>Match the current character if it matches and continue with the same pattern (<code>dp[i+1][j]</code>)</li> </ul> </li> <li>If the next character is not '*', simply check if current characters match and move forward</li> </ul> </li> </ol>"},{"location":"Hard/10%20Regular%20Expression%20Matching/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(m*n)</li> <li>Space complexity: O(m*n)</li> </ul>"},{"location":"Hard/10%20Regular%20Expression%20Matching/#keywords","title":"Keywords","text":"<ul> <li>Dynamic Programming</li> <li>String Matching</li> <li>Regular Expression</li> <li>Pattern Matching</li> </ul>"},{"location":"Hard/10%20Regular%20Expression%20Matching/#code","title":"Code","text":"<pre><code>func isMatch(s string, p string) bool {\n    n, m := len(s), len(p)\n    dp := make([][]bool, n + 1)\n    for i := range dp {\n        dp[i] = make([]bool, m + 1)\n    }\n    dp[n][m] = true\n\n    for i := n; i &gt;= 0; i -= 1 {\n        for j := m - 1; j &gt;= 0; j -= 1 {\n            currentMatch := i &lt; n &amp;&amp; (s[i] == p[j] || p[j] == '.')\n\n            if j + 1 &lt; m &amp;&amp; p[j + 1] == '*' {\n                dp[i][j] = dp[i][j + 2] || (currentMatch &amp;&amp; dp[i + 1][j])\n            } else {\n                dp[i][j] = currentMatch &amp;&amp; dp[i + 1][j + 1]\n            }\n        }\n    }\n\n    return dp[0][0]\n}\n</code></pre>"},{"location":"Hard/124%20Binary%20Tree%20Maximum%20Path%20Sum/","title":"124. Binary Tree Maximum Path Sum","text":""},{"location":"Hard/124%20Binary%20Tree%20Maximum%20Path%20Sum/#intuition","title":"Intuition","text":"<p>The maximum path sum in a binary tree can be found by considering all possible paths that pass through each node. For any given node, the maximum path sum could be:</p> <ol> <li>The node's value itself</li> <li>The node's value plus the maximum path from its left subtree</li> <li>The node's value plus the maximum path from its right subtree</li> <li>The node's value plus both left and right maximum paths</li> </ol>"},{"location":"Hard/124%20Binary%20Tree%20Maximum%20Path%20Sum/#approach","title":"Approach","text":"<p>We use a post-order traversal approach to solve this problem:</p> <ol> <li>For each node, we recursively calculate the maximum path sum from its left and right subtrees</li> <li>We update the global maximum by considering all possible combinations:<ul> <li>The current node's value alone</li> <li>Current node + left path</li> <li>Current node + right path</li> <li>Current node + left path + right path</li> </ul> </li> <li>We return the maximum path sum that can be extended from the current node to its parent (which can only include at most one of its children)</li> </ol>"},{"location":"Hard/124%20Binary%20Tree%20Maximum%20Path%20Sum/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(n)</li> <li>Space complexity: O(h)</li> </ul>"},{"location":"Hard/124%20Binary%20Tree%20Maximum%20Path%20Sum/#keywords","title":"Keywords","text":"<ul> <li>Binary Tree</li> <li>Post-order Traversal</li> <li>Recursion</li> </ul>"},{"location":"Hard/124%20Binary%20Tree%20Maximum%20Path%20Sum/#code","title":"Code","text":"<pre><code>/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc maxPathSum(root *TreeNode) int {\n    ret := math.MinInt\n    var postOrder func(node *TreeNode) int\n    postOrder = func(node *TreeNode) int {\n        if node == nil {\n            return 0\n        }\n        left, right := postOrder(node.Left), postOrder(node.Right)\n        ret = max(ret, left + right + node.Val, left + node.Val, right + node.Val, node.Val)\n        return max(left + node.Val, right + node.Val, node.Val)\n    }\n    ret = max(ret, postOrder(root))\n    return ret\n}\n</code></pre>"},{"location":"Hard/135%20Candy/","title":"135 Candy","text":""},{"location":"Hard/135%20Candy/#intuition","title":"Intuition","text":"<p>For candy distribution, I use two times of traversal from left to right and right to left, and record the number of candies satisfied the requirement.</p>"},{"location":"Hard/135%20Candy/#approach","title":"Approach","text":"<ol> <li>First, initialize a candy array of the same length as the ratings array</li> <li>First pass (left to right):<ul> <li>For the first child, give 2 candies if their rating is higher than the second child, otherwise give 1</li> <li>For other children, if the current child's rating is higher than the left neighbor, give them 1 more candy than the left neighbor; otherwise, give just 1 candy</li> </ul> </li> <li>Second pass (right to left):<ul> <li>For each child, check their rating relationship with the right neighbor</li> <li>If the current child's rating is higher than the right neighbor, they should have at least 1 more candy than the right neighbor</li> <li>Take the maximum of the current value and the newly calculated value to ensure requirements from both directions are satisfied</li> </ul> </li> <li>During the second pass, accumulate the total number of candies given to all children</li> </ol>"},{"location":"Hard/135%20Candy/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(N)</li> <li>Space complexity:O(N)</li> </ul>"},{"location":"Hard/135%20Candy/#keywords","title":"Keywords","text":"<ul> <li>Greedy</li> </ul>"},{"location":"Hard/135%20Candy/#code","title":"Code","text":"<pre><code>func candy(ratings []int) int {\n    if len(ratings) == 1 {\n        return 1\n    }\n\n    ret, candy := 0, make([]int, len(ratings))\n\n    if ratings[0] &gt; ratings[1] {\n        candy[0] = 2\n    } else {\n        candy[0] = 1\n    }\n    for i := 1; i &lt; len(ratings); i += 1 {\n        if ratings[i] &lt;= ratings[i - 1] {\n            candy[i] = 1\n        } else {\n            candy[i] = candy[i - 1] + 1\n        }\n    }\n\n    ret = candy[len(candy) - 1]\n    for i := len(ratings) - 2; i &gt;= 0; i -= 1 {\n        if ratings[i] &lt;= ratings[i + 1] {\n            candy[i] =  max(candy[i], 1)\n        } else {\n            candy[i] = max(candy[i], candy[i + 1] + 1)\n        }\n        ret += candy[i]\n    }\n\n    return ret\n}\n</code></pre>"},{"location":"Hard/140%20Word%20Break%20II/","title":"140. Work Break II","text":""},{"location":"Hard/140%20Word%20Break%20II/#intuition","title":"Intuition","text":"<p>We need to explore all possible combinations of words that can form the input string. This naturally leads to a recursive approach where we try different word combinations at each step.</p>"},{"location":"Hard/140%20Word%20Break%20II/#approach","title":"Approach","text":"<ol> <li>First, we create a map of valid words from the dictionary for O(1) lookup.</li> <li>We use a recursive function that:<ul> <li>Builds the current word character by character</li> <li>When a valid word is found, we have two choices:<ol> <li>Add the word to our current path and start a new word</li> <li>Continue building the current word</li> </ol> </li> </ul> </li> <li>When we reach the end of the string with a valid word, we join all words in the current path with spaces and add it to our result.</li> <li>The recursion explores all possible combinations of words that can form the input string.</li> </ol>"},{"location":"Hard/140%20Word%20Break%20II/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(2^n)</li> <li>Space complexity: O(n)</li> </ul>"},{"location":"Hard/140%20Word%20Break%20II/#keywords","title":"Keywords","text":"<ul> <li>Recursion</li> <li>Backtracking</li> <li>DFS</li> </ul>"},{"location":"Hard/140%20Word%20Break%20II/#code","title":"Code","text":"<pre><code>func wordBreak(s string, wordDict []string) []string {\n    ret, wordMap := make([]string, 0), make(map[string]bool)\n    for _, word := range wordDict {\n        wordMap[word] = true\n    }\n\n    var recur func(curI int, curWord string, curStr []string)\n    recur = func(curI int, curWord string, curStr []string) {\n        if curI == len(s) {\n            return\n        }\n        curWord += string(s[curI])\n        if wordMap[curWord] {\n            tmp := make([]string, len(curStr))\n            copy(tmp, curStr)\n            tmp = append(tmp, curWord)\n            if curI == len(s) - 1 {\n                retStr := strings.Join(tmp, \" \")\n                ret = append(ret, retStr)    \n            } else {\n                recur(curI + 1, \"\", tmp)\n            }\n        }\n        recur(curI + 1, curWord, curStr)\n    }\n\n    recur(0, \"\", make([]string, 0))\n    return ret\n}\n</code></pre>"},{"location":"Hard/2071%20Maximum%20Number%20of%20Tasks%20You%20Can%20Assign/","title":"2071. Maximum Number of Tasks You Can Assign","text":""},{"location":"Hard/2071%20Maximum%20Number%20of%20Tasks%20You%20Can%20Assign/#intuition","title":"Intuition","text":"<p>The problem asks us to find the maximum number of tasks we can assign to workers, where each worker can complete at most one task. Workers have different strengths, tasks have different requirements, and we have a limited number of pills that can boost a worker's strength by a fixed amount.</p> <p>The key insight is that this is an optimization problem where we want to maximize the number of completed tasks. We can use binary search on the answer - if we can complete k tasks, we might be able to complete k+1 tasks, but if we can't complete k tasks, we definitely can't complete more than k tasks.</p>"},{"location":"Hard/2071%20Maximum%20Number%20of%20Tasks%20You%20Can%20Assign/#approach","title":"Approach","text":"<ol> <li>Sort both arrays: Sort tasks in ascending order and workers in descending order of their strength.</li> <li>Binary search on the answer: Use binary search to find the maximum number of tasks we can complete. The search space is from 0 to min(len(tasks), len(workers)).</li> <li>Greedy assignment strategy: For a given number k of tasks to complete:<ul> <li>Take the k easiest tasks (first k tasks after sorting)</li> <li>Take the k strongest workers (last k workers after sorting)</li> <li>Process tasks from hardest to easiest among the selected k tasks</li> <li>For each task, try to assign it using the greedy strategy:<ul> <li>First, try to assign the strongest available worker without using a pill</li> <li>If that's not possible, find the weakest worker who can complete the task with a pill</li> <li>If no worker can complete the task even with a pill, return false</li> </ul> </li> </ul> </li> <li>Optimization with pills: When we need to use a pill, we should use it on the weakest possible worker who can complete the task. This preserves stronger workers for harder tasks.</li> </ol> <p>The greedy strategy works because:</p> <ul> <li>We process harder tasks first, ensuring they get priority for stronger workers</li> <li>When using pills, we use them on the weakest capable worker to preserve stronger workers</li> <li>This maximizes our chances of completing all k tasks</li> </ul>"},{"location":"Hard/2071%20Maximum%20Number%20of%20Tasks%20You%20Can%20Assign/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(n log n + m log m + log(min(n,m)) \u00d7 m log m)</li> <li>Space complexity: O(m)</li> </ul>"},{"location":"Hard/2071%20Maximum%20Number%20of%20Tasks%20You%20Can%20Assign/#keywords","title":"Keywords","text":"<ul> <li>Binary Search</li> <li>Greedy Algorithm</li> </ul>"},{"location":"Hard/2071%20Maximum%20Number%20of%20Tasks%20You%20Can%20Assign/#code","title":"Code","text":"<pre><code>func maxTaskAssign(tasks []int, workers []int, pills int, strength int) int {\n    sort.Ints(tasks)\n    sort.Ints(workers)\n\n    canAssign := func(k int) bool {\n        avail, remain := append(make([]int, 0), workers[len(workers) - k:]...), pills\n        for i := k - 1; i &gt;= 0; i -= 1 {\n            require := tasks[i]\n            if len(avail) &gt; 0 &amp;&amp; avail[len(avail) - 1] &gt;= require {\n                avail = avail[: len(avail) - 1]\n            } else {\n                if remain &lt;= 0 {\n                    return false\n                }\n                thresold := require - strength\n                idx := sort.Search(len(avail), func(j int) bool {\n                    return avail[j] &gt;= thresold\n                })\n                if idx == len(avail) {\n                    return false\n                }\n                avail = append(avail[:idx], avail[idx + 1:]...)\n                remain -= 1\n            }\n        }\n        return true\n    }\n\n    left, right, complete := 0, min(len(tasks), len(workers)), 0\n    for left &lt;= right {\n        mid := (left + right) / 2\n        if canAssign(mid) {\n            complete, left = mid, mid + 1\n        } else {\n            right = mid - 1\n        }\n    }\n    return complete\n}\n</code></pre>"},{"location":"Hard/220%20Contains%20Duplicate%20III/","title":"220. Contains Duplicate III","text":""},{"location":"Hard/220%20Contains%20Duplicate%20III/#intuition","title":"Intuition","text":"<p>The problem asks us to find if there are two distinct indices i and j such that:</p> <ol> <li>The absolute difference between indices is at most k: |i - j| &lt;= k</li> <li>The absolute difference between values is at most t: |nums[i] - nums[j]| &lt;= t</li> </ol> <p>The key insight is to use a bucket sort approach where we group numbers into buckets of size (t + 1). If two numbers are in the same bucket, their difference is guaranteed to be &lt;= t. We also need to check adjacent buckets since numbers in neighboring buckets might have a difference &lt;= t.</p>"},{"location":"Hard/220%20Contains%20Duplicate%20III/#approach","title":"Approach","text":"<ol> <li>Bucket Strategy: Create buckets of width (t + 1). Numbers in the same bucket will have a difference &lt;= t.</li> <li>Bucket Index Calculation:<ul> <li>For positive numbers: <code>bucketIdx = num / width</code></li> <li>For negative numbers: <code>bucketIdx = (num / width) - 1</code> (to handle negative division correctly)</li> </ul> </li> <li>Three Checks for Each Number:<ul> <li>Same bucket: If current bucket already has a number, return true</li> <li>Right adjacent bucket: Check if |num - bucket[bucketIdx + 1]| &lt;= t</li> <li>Left adjacent bucket: Check if |num - bucket[bucketIdx - 1]| &lt;= t</li> </ul> </li> <li>Sliding Window: Maintain at most k+1 elements by removing the element that's k+1 positions behind the current element.</li> <li>Edge Case Handling: Special handling for negative numbers to ensure correct bucket assignment.</li> </ol>"},{"location":"Hard/220%20Contains%20Duplicate%20III/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(n)</li> <li>Space complexity: O(min(n, k))</li> </ul>"},{"location":"Hard/220%20Contains%20Duplicate%20III/#keywords","title":"Keywords","text":"<ul> <li>Bucket Sort</li> <li>Sliding Window</li> <li>Hash Map</li> </ul>"},{"location":"Hard/220%20Contains%20Duplicate%20III/#code","title":"Code","text":"<pre><code>func containsNearbyAlmostDuplicate(nums []int, k int, t int) bool {\n    abs := func(x int) int {\n        if x &lt; 0 {\n            return -x\n        }\n        return x\n    }\n\n    bucket, width := make(map[int]int), t + 1\n    for i, num := range nums {\n        var bucketIdx int\n\n        if num &gt;= 0 {\n            bucketIdx = num / width\n        } else {\n            bucketIdx = (num / width) - 1\n        }\n\n        if _, exist := bucket[bucketIdx]; exist {\n            return true\n        }\n        if n, exist := bucket[bucketIdx + 1]; exist &amp;&amp; abs(num - n) &lt; width {\n            return true\n        }\n        if n, exist := bucket[bucketIdx - 1]; exist &amp;&amp; abs(num - n) &lt; width {\n            return true\n        }\n\n        bucket[bucketIdx] = num\n\n        if i &gt;= k {\n            var delBucketIdx int\n\n            if nums[i - k] &gt;= 0 {\n                delBucketIdx = nums[i - k] / width\n            } else {\n                delBucketIdx = (nums[i - k] / width) - 1\n            }\n\n            delete(bucket, delBucketIdx)\n        }\n    }\n    return false\n}\n</code></pre>"},{"location":"Hard/23%20Merge%20k%20Sorted%20Lists/","title":"23. Merge k Sorted List","text":""},{"location":"Hard/23%20Merge%20k%20Sorted%20Lists/#intuition","title":"Intuition","text":"<p>To merge k sorted linked lists efficiently, we can use a min heap (priority queue) to always get the smallest element among all lists. This approach allows us to maintain a sorted order while merging the lists.</p>"},{"location":"Hard/23%20Merge%20k%20Sorted%20Lists/#approach","title":"Approach","text":"<ol> <li>Create a min heap to store the head nodes of all k lists</li> <li>Initialize the heap with the first node from each list (if not nil)</li> <li>Create a dummy node to build the result list</li> <li>While the heap is not empty:<ul> <li>Extract the minimum node from the heap</li> <li>Add it to the result list</li> <li>If the extracted node has a next node, push it back into the heap</li> </ul> </li> <li>Return the merged list</li> </ol>"},{"location":"Hard/23%20Merge%20k%20Sorted%20Lists/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(N log k)</li> <li>Space complexity: O(k)</li> </ul>"},{"location":"Hard/23%20Merge%20k%20Sorted%20Lists/#keywords","title":"Keywords","text":"<ul> <li>Linked List</li> <li>Heap/Priority Queue</li> <li>Merge Sort</li> </ul>"},{"location":"Hard/23%20Merge%20k%20Sorted%20Lists/#code","title":"Code","text":"<pre><code>/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\ntype Comparator func(child, parent interface{}) bool\ntype heap struct {\n    Storage []interface{}\n    CmpFunc Comparator\n}\n\nfunc NewHeap(cmpFunc Comparator) *heap {\n    return &amp;heap {\n        Storage: append(make([]interface{}, 0), -1),\n        CmpFunc: cmpFunc,\n    }\n}\n\nfunc (h *heap) Len() int {\n    return len(h.Storage) - 1\n}\n\nfunc (h *heap) IsEmpty() bool {\n    return h.Len() == 0\n}\n\nfunc (h *heap) cmp(child, parent interface{}) bool {\n    return h.CmpFunc(child, parent)\n}\n\nfunc (h *heap) swap(x, y int) {\n    h.Storage[x], h.Storage[y] = h.Storage[y], h.Storage[x]\n}\n\nfunc (h *heap) Top() (interface{}, error) {\n    if h.IsEmpty() {\n        return nil, errors.New(\"Heap is empty.\")\n    }\n    return h.Storage[1], nil\n}\n\nfunc (h *heap) Push(item interface{}) {\n    h.Storage = append(h.Storage, item)\n    now := h.Len()\n    for now / 2 &gt; 0 &amp;&amp; !h.cmp(h.Storage[now], h.Storage[now / 2]) {\n        h.swap(now, now / 2)\n        now /= 2\n    }\n}\n\nfunc (h *heap) Pop() (interface{}, error) {\n    top, err := h.Top()\n    if err != nil {\n        return nil, err\n    }\n    last := h.Len()\n    h.swap(1, last)\n    h.Storage = h.Storage[: last]\n    now := 1\n    for now &lt; last {\n        left, right := 0, 0\n        if now * 2 &lt; last &amp;&amp; !h.cmp(h.Storage[now * 2], h.Storage[now]) {\n            left = now * 2\n        }\n        if now * 2 + 1 &lt; last &amp;&amp; !h.cmp(h.Storage[now * 2 + 1], h.Storage[now]) {\n            right = now * 2 + 1\n        }\n\n        if left == 0 &amp;&amp; right == 0 {\n            break\n        } else if left != 0 &amp;&amp; right == 0 {\n            h.swap(now, left)\n            now = left\n        } else if left == 0 &amp;&amp; right != 0 {\n            h.swap(now, right)\n            now = right\n        } else {\n            if h.cmp(h.Storage[left], h.Storage[right]) {\n                h.swap(now, right)\n                now = right\n            } else {\n                h.swap(now, left)\n                now = left\n            }\n        }\n    }\n    return top, nil\n}\n\nfunc mergeKLists(lists []*ListNode) *ListNode {\n    if len(lists) == 0 {\n        return nil\n    }\n    cmpFunc := func(child, parent interface{}) bool {\n        return child.(*ListNode).Val &gt; parent.(*ListNode).Val\n    }\n    hp := NewHeap(cmpFunc)\n    for _, node := range lists {\n        if node != nil {\n            hp.Push(node)\n        }\n    }\n    prev := &amp;ListNode{Val: 0, Next: nil}\n    cur := prev\n    for !hp.IsEmpty() {\n        top, _ := hp.Pop()\n        cur.Next = top.(*ListNode)\n        cur = cur.Next\n        if next := top.(*ListNode).Next; next != nil {\n            hp.Push(next)\n        }\n    }\n    return prev.Next\n}\n</code></pre>"},{"location":"Hard/2366%20Minimum%20Replacements%20to%20Sort%20the%20Array/","title":"2366. Minimum Replacement to Sort the Array","text":""},{"location":"Hard/2366%20Minimum%20Replacements%20to%20Sort%20the%20Array/#intuition","title":"Intuition","text":"<p>This is definitely math question. The two key points are to compute <code>parts</code> and the <code>prev</code> value. As the hint saying, we need to start from the second-to-last since the last one can't be splitted.</p>"},{"location":"Hard/2366%20Minimum%20Replacements%20to%20Sort%20the%20Array/#approach","title":"Approach","text":"<ol> <li>Start traversing from the second-to-last element of the array</li> <li>For each element nums[i], if it's greater than the previously processed element prev:<ul> <li>Calculate how many parts we need to split the current number into: <code>(num + prev - 1) / prev</code></li> <li>Update prev to be the minimum value after splitting: <code>num / parts</code></li> <li>Add the number of operations needed: <code>partss - 1</code></li> </ul> </li> <li>If the current element is less than or equal to prev, no splitting is needed</li> <li>Return the total number of operations</li> </ol>"},{"location":"Hard/2366%20Minimum%20Replacements%20to%20Sort%20the%20Array/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(n)</li> <li>Space complexity: O(1)</li> </ul>"},{"location":"Hard/2366%20Minimum%20Replacements%20to%20Sort%20the%20Array/#keywords","title":"Keywords","text":"<ul> <li>Greedy Algorithm</li> <li>Mathematics</li> </ul>"},{"location":"Hard/2366%20Minimum%20Replacements%20to%20Sort%20the%20Array/#code","title":"Code","text":"<pre><code>func minimumReplacement(nums []int) int64 {\n    if len(nums) == 1 {\n        return 0\n    }\n    ret := int64(0)\n    var split func(num int, prev *int) int\n    split = func(num int, prev *int) int {\n        if num &lt;= *prev {\n            *prev = num\n            return 0\n        }\n        tmp := (num + *prev - 1) / *prev\n        *prev = num / tmp\n        return tmp - 1\n    }\n    prev := nums[len(nums) - 1]\n    for i := len(nums) - 2; i &gt;= 0; i -= 1 {\n        ret += int64(split(nums[i], &amp;prev))\n    }\n    return ret\n}\n</code></pre>"},{"location":"Hard/239%20Sliding%20Window%20Maximum/","title":"239. Sliding Window Maximum","text":""},{"location":"Hard/239%20Sliding%20Window%20Maximum/#intuition","title":"Intuition","text":"<p>The key concepts of the problem is to maintain a \"MAX\" list.</p>"},{"location":"Hard/239%20Sliding%20Window%20Maximum/#approach","title":"Approach","text":"<p>For each round, you need to remove the indexes from queue if the corresponding element in <code>nums</code> are smaller than curent number.</p> <p>After remove all the smaller elements, append the current number to the queue.</p> <p>Check the indexes in queue is in <code>k</code> range; otherwise, remove them.</p> <p>Finally, take the first index in <code>queue</code> and append the corresponding number to the return slice from <code>nums</code>.</p> <p>(<code>queue</code> will maintain a large to small list.)</p>"},{"location":"Hard/239%20Sliding%20Window%20Maximum/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(N)</li> <li>Space complexity: O(k)</li> </ul>"},{"location":"Hard/239%20Sliding%20Window%20Maximum/#keywords","title":"Keywords","text":"<ul> <li>Sliding Window</li> <li>Array</li> </ul>"},{"location":"Hard/239%20Sliding%20Window%20Maximum/#code","title":"Code","text":"<pre><code>func maxSlidingWindow(nums []int, k int) []int {\n    queue, ret := make([]int, 0), make([]int, 0)\n\n    for i, num := range nums {\n        for len(queue) &gt; 0 &amp;&amp; nums[queue[len(queue) - 1]] &lt; num {\n            queue = queue[: len(queue) - 1]\n        }\n        queue = append(queue, i)\n\n        if queue[0] &lt;= i - k {\n            queue = queue[1:]\n        }\n\n        if i &gt;= k - 1 {\n            ret = append(ret, nums[queue[0]])\n        }\n    }\n\n    return ret\n}\n</code></pre>"},{"location":"Hard/2392%20Build%20A%20Matrix%20With%20Conditions/","title":"2392 Build a Matrix With Conditions","text":""},{"location":"Hard/2392%20Build%20A%20Matrix%20With%20Conditions/#intuition","title":"Intuition","text":"<p>Think is problem as a \"GRAPH\" problem. The first and second number in x-conditions just like a from u to v edge. Then, use topological sort to solve this problem.</p>"},{"location":"Hard/2392%20Build%20A%20Matrix%20With%20Conditions/#approach","title":"Approach","text":"<p>First, we can convert the x-conditions as a graph. I store the graph as four parts: number of vertices \\ adjacency list \\ roots whose indegree are '0' \\ indegree of each vertice.</p> <p>Second, go on topological sort on row-Graph and col-Graph. I store the result in a map which indicates {vertice: index in row / col}. In the 'for' loop, g.Roots acts as the queue for BFS. The top of the queue as it is popped out will be put in the order map with the val is which index it would be. And if its adjacent vertice's indegree is decrease to zero, I push this vertice into the queue, i.e. g.Roots.</p> <p>Last, just put the result in the return matrix.</p> <p>Be carefulthat in each step you need to check whether there exist cycle or not, i.e. the error condition in each function.</p>"},{"location":"Hard/2392%20Build%20A%20Matrix%20With%20Conditions/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(N+E)</li> <li>Space complexity: O(N)</li> </ul>"},{"location":"Hard/2392%20Build%20A%20Matrix%20With%20Conditions/#keywords","title":"Keywords","text":"<ul> <li>Topological Sort</li> <li>Graph</li> <li>Matrix</li> </ul>"},{"location":"Hard/2392%20Build%20A%20Matrix%20With%20Conditions/#code","title":"Code","text":"<pre><code>type Graph struct {\n    Verts   int\n    AdjList map[int][]int\n    Roots []int\n    Indegree map[int]int\n}\n\nfunc NewGraph(k int, conditions [][]int) (*Graph, error) {\n    g := Graph{\n        Verts: k,\n        AdjList: make(map[int][]int),\n        Roots: make([]int, 0),\n        Indegree: make(map[int]int),\n    }\n    for i := 1; i &lt; k + 1; i += 1 {\n        g.Indegree[i] = 0\n    }\n    for _, cond := range conditions {\n        u, v := cond[0], cond[1]\n        g.AdjList[u] = append(g.AdjList[u], v)\n        g.Indegree[v] += 1\n    }\n    for key, val := range g.Indegree {\n        if val == 0 {\n            g.Roots = append(g.Roots, key)\n        }\n    }\n    if len(g.Roots) == 0 {\n        return nil, errors.New(\"\")\n    }\n    return &amp;g, nil\n}\n\nfunc (g *Graph) TopologicalSort() (map[int]int, error) {\n    order, idx := make(map[int]int), 0\n    for len(g.Roots) != 0 {\n        top := g.Roots[0]\n        g.Roots = g.Roots[1:]\n        order[top] = idx\n        idx += 1\n        for _, adj := range g.AdjList[top] {\n            g.Indegree[adj] -= 1\n            if g.Indegree[adj] == 0 {\n                g.Roots = append(g.Roots, adj)\n            }\n        }\n    }\n    if len(order) != g.Verts {\n        return nil, errors.New(\"\")\n    }\n    return order, nil\n}\n\nfunc buildMatrix(k int, rowConditions [][]int, colConditions [][]int) [][]int {\n    rowGraph, err := NewGraph(k, rowConditions)\n    if err != nil {\n        return make([][]int, 0)\n    }\n    colGraph, err := NewGraph(k, colConditions)\n    if err != nil {\n        return make([][]int, 0)\n    }\n\n    rowTopo, err := rowGraph.TopologicalSort()\n    if err != nil {\n        return make([][]int, 0)\n    }\n    colTopo, err := colGraph.TopologicalSort()\n    if err != nil {\n        return make([][]int, 0)\n    }\n    rowGraph, colGraph = nil, nil\n\n    ret := make([][]int, k)\n    for i := 0; i &lt; k; i += 1 {\n        ret[i] = make([]int, k)\n    }\n\n    for i := 1; i &lt; k + 1; i += 1 {\n        ret[rowTopo[i]][colTopo[i]] = i\n    }\n\n    return ret\n}\n</code></pre>"},{"location":"Hard/2444%20Count%20Subarrays%20With%20Fixed%20Bounds/","title":"2444. Count Subarrays With Fixed Bounds","text":""},{"location":"Hard/2444%20Count%20Subarrays%20With%20Fixed%20Bounds/#intuition","title":"Intuition","text":"<p>For a subarray to be valid, it must:</p> <ol> <li>Contain both minK and maxK</li> <li>Have all elements between minK and maxK (inclusive)</li> <li>Start after any \"bad\" number (numbers outside the range [minK, maxK])</li> </ol>"},{"location":"Hard/2444%20Count%20Subarrays%20With%20Fixed%20Bounds/#approach","title":"Approach","text":"<p>We use a sliding window technique with three pointers:</p> <ol> <li><code>minIdx</code>: Position of the last occurrence of minK</li> <li><code>maxIdx</code>: Position of the last occurrence of maxK</li> <li><code>badIdx</code>: Position of the last number that's outside our bounds</li> </ol> <p>For each position i:</p> <ol> <li>Update <code>badIdx</code> if current number is out of bounds</li> <li>Update <code>minIdx</code> if we see minK</li> <li>Update <code>maxIdx</code> if we see maxK</li> <li>If both minK and maxK appear after badIdx, we can form valid subarrays<ul> <li>The number of valid subarrays ending at i is: min(minIdx, maxIdx) - badIdx</li> </ul> </li> </ol>"},{"location":"Hard/2444%20Count%20Subarrays%20With%20Fixed%20Bounds/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(n)</li> <li>Space complexity: O(1)</li> </ul>"},{"location":"Hard/2444%20Count%20Subarrays%20With%20Fixed%20Bounds/#keywords","title":"Keywords","text":"<ul> <li>Sliding Window</li> <li>Two Pointers</li> <li>Subarray Count</li> </ul>"},{"location":"Hard/2444%20Count%20Subarrays%20With%20Fixed%20Bounds/#code","title":"Code","text":"<pre><code>func countSubarrays(nums []int, minK int, maxK int) int64 {\n    ret, minIdx, maxIdx, badIdx := int64(0), -1, -1, -1\n\n    for i, num := range nums {\n        if num &lt; minK || num &gt; maxK {\n            badIdx = i\n        }\n        if num == minK {\n            minIdx = i\n        }\n        if num == maxK {\n            maxIdx = i\n        }\n        idx := min(minIdx, maxIdx)\n        if idx &gt; badIdx {\n            ret += int64(idx - badIdx)\n        }\n    }\n\n    return ret\n}\n</code></pre>"},{"location":"Hard/25%20Reverse%20Nodes%20in%20k-Group/","title":"25. Reverse Nodes in k-Group","text":""},{"location":"Hard/25%20Reverse%20Nodes%20in%20k-Group/#intuition","title":"Intuition","text":"<p>To reverse nodes in k-group, we need to:</p> <ol> <li>Check if there are at least k nodes left in the list</li> <li>If yes, reverse those k nodes as a group</li> <li>Connect the previous part with the reversed group and the remaining list</li> <li>Continue this process until we can't form groups of k nodes</li> </ol>"},{"location":"Hard/25%20Reverse%20Nodes%20in%20k-Group/#approach","title":"Approach","text":"<ol> <li>Create a dummy node as the previous node of the head to handle edge cases</li> <li>Define a closure function <code>Reverse</code> that:<ul> <li>Takes a node and reverses the next k nodes</li> <li>Returns the new start and end of the reversed group</li> </ul> </li> <li>Iterate through the list:<ul> <li>Check if there are k nodes ahead</li> <li>If yes, reverse them using the <code>Reverse</code> function</li> <li>Update pointers to connect the reversed group</li> <li>Move to the end of the current group</li> </ul> </li> <li>Return the next node of dummy (the new head)</li> </ol>"},{"location":"Hard/25%20Reverse%20Nodes%20in%20k-Group/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(n)</li> <li>Space complexity: O(1)</li> </ul>"},{"location":"Hard/25%20Reverse%20Nodes%20in%20k-Group/#keywords","title":"Keywords","text":"<ul> <li>Linked List</li> <li>Reversal</li> </ul>"},{"location":"Hard/25%20Reverse%20Nodes%20in%20k-Group/#code","title":"Code","text":"<pre><code>/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc reverseKGroup(head *ListNode, k int) *ListNode {\n    prev := &amp;ListNode{Val: 0, Next: head}\n    cur := prev\n    Reverse := func(now *ListNode) (*ListNode, *ListNode) {\n        end, head := now.Next, now.Next.Next\n        rec, n := end, k - 1\n        rec.Next = nil\n        for n &gt; 0 {\n            tmp := head.Next\n            head.Next = end\n            end = head\n            head = tmp\n            n -= 1\n        }\n        rec.Next = head\n        return end, rec\n    }\n    for cur != nil {\n        n, tmp := k, cur\n        for n &gt; 0 {\n            tmp = tmp.Next\n            if tmp == nil {\n                goto RET\n            }\n            n -= 1\n        }\n        tmp = tmp.Next\n        var start *ListNode\n        cur.Next, start = Reverse(cur)\n        cur = start\n    }\nRET:\n    return prev.Next\n}\n</code></pre>"},{"location":"Hard/2742%20Painting%20the%20Walls/","title":"2742. Painting the Walls","text":""},{"location":"Hard/2742%20Painting%20the%20Walls/#intuition","title":"Intuition","text":"<p>The key insight is that while a paid painter is painting one wall, the free painter can paint other walls during that time. We can use this to optimize our solution by considering the trade-off between cost and time.</p>"},{"location":"Hard/2742%20Painting%20the%20Walls/#approach","title":"Approach","text":"<ol> <li>We use dynamic programming where <code>dp[i]</code> represents the minimum cost to paint <code>i</code> walls</li> <li>Initialize dp array with maximum values except dp[0] = 0</li> <li>For each wall:<ul> <li>We consider using the paid painter for this wall</li> <li>While paid painter works on current wall, free painter can paint <code>time[i]</code> walls</li> <li>We update dp[k] where k is min(total_walls, current_walls + 1 + time[i])</li> <li>The minimum cost would be either existing cost or cost of painting current wall plus previous state</li> </ul> </li> <li>The final answer is stored in dp[len(cost)]</li> </ol>"},{"location":"Hard/2742%20Painting%20the%20Walls/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(n^2)</li> <li>Space complexity: O(n)</li> </ul>"},{"location":"Hard/2742%20Painting%20the%20Walls/#keywords","title":"Keywords","text":"<ul> <li>Dynamic Programming</li> <li>Array</li> <li>Optimization</li> <li>Minimum Cost</li> <li>Two Painters Problem</li> </ul>"},{"location":"Hard/2742%20Painting%20the%20Walls/#code","title":"Code","text":"<pre><code>func paintWalls(cost []int, time []int) int {\n    dp := make([]int, len(cost)+1)\n    for i := range dp {\n        dp[i] = math.MaxInt32\n    }\n    dp[0] = 0\n\n    for i := range cost {\n        for j := len(cost)-1; j &gt;= 0; j -= 1 {\n            k := min(len(cost), j+1+time[i])\n            dp[k] = min(dp[k], dp[j]+cost[i])\n        }\n    }\n\n    return dp[len(cost)]\n}\n</code></pre>"},{"location":"Hard/312%20Burst%20Balloons/","title":"312. Burst Balloons","text":""},{"location":"Hard/312%20Burst%20Balloons/#intuition","title":"Intuition","text":"<p>The key insight is to think about the problem in reverse: instead of bursting balloons one by one, we can think about adding balloons back one by one. For each step, we consider which balloon to add last.</p>"},{"location":"Hard/312%20Burst%20Balloons/#approach","title":"Approach","text":"<ol> <li>Add two dummy balloons with value 1 at the beginning and end of the array.</li> <li>Define <code>dp[left][right]</code> as the maximum coins that can be collected by bursting all balloons between indices left and right (exclusive).</li> <li>For each subproblem of length, we try each balloon (at position tmp) as the last one to burst.</li> <li>The recurrence relation is:    <code>dp[left][right] = max(dp[left][right], dp[left][tmp] + dp[tmp][right] + nums[left] * nums[tmp] * nums[right])</code></li> <li>The final answer is <code>dp[0][n+1]</code>, representing the maximum coins obtained by bursting all original balloons.</li> </ol>"},{"location":"Hard/312%20Burst%20Balloons/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(n\u00b3)</li> <li>Space complexity: O(n\u00b2)</li> </ul>"},{"location":"Hard/312%20Burst%20Balloons/#keywords","title":"Keywords","text":"<ul> <li>Dynamic Programming</li> <li>Interval DP</li> </ul>"},{"location":"Hard/312%20Burst%20Balloons/#code","title":"Code","text":"<pre><code>func maxCoins(nums []int) int {\n    nums = append([]int{1}, nums...)\n    nums = append(nums, 1)\n\n    dp := make([][]int, len(nums))\n    for i := range dp {\n        dp[i] = make([]int, len(nums))\n    }\n\n    for length := 2; length &lt; len(nums); length += 1 {\n        for left := 0; left &lt; len(nums) - length; left += 1 {\n            right := left + length\n            for tmp := left + 1; tmp &lt; right; tmp += 1 {\n                dp[left][right] = max(dp[left][right], dp[left][tmp] + dp[tmp][right] + nums[left] * nums[tmp] * nums[right])\n            }\n        }\n    }\n\n    return dp[0][len(nums) - 1]\n}\n</code></pre>"},{"location":"Hard/3373%20Maximize%20the%20Number%20of%20Target%20Nodes%20After%20Connecting%20Trees%20II/","title":"3373. Maximize the Number of Target Nodes After Connecting Trees II","text":""},{"location":"Hard/3373%20Maximize%20the%20Number%20of%20Target%20Nodes%20After%20Connecting%20Trees%20II/#intuition","title":"Intuition","text":"<p>The key insight is that when connecting two trees at any node, the nodes at even levels in one tree can be made to align with either even or odd levels in the other tree, depending on which maximizes our target nodes.</p>"},{"location":"Hard/3373%20Maximize%20the%20Number%20of%20Target%20Nodes%20After%20Connecting%20Trees%20II/#approach","title":"Approach","text":"<ol> <li>First, we build adjacency lists for both trees using the given edges.</li> <li>For each tree, we perform a BFS starting from node 0 to:<ul> <li>Mark nodes at even levels (including level 0)</li> <li>Count the number of nodes at even and odd levels</li> <li>Store this information in a boolean slice for tree1</li> </ul> </li> <li>For each node in tree1:<ul> <li>If it's at an even level (true in tree1Even), we can connect it to get:<ul> <li>All even nodes from tree1 (even1) + max(even2, odd2) from tree2</li> </ul> </li> <li>If it's at an odd level (false in tree1Even), we can connect it to get:<ul> <li>All odd nodes from tree1 (odd1) + max(even2, odd2) from tree2</li> </ul> </li> </ul> </li> </ol>"},{"location":"Hard/3373%20Maximize%20the%20Number%20of%20Target%20Nodes%20After%20Connecting%20Trees%20II/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(N + E)</li> <li>Space complexity: O(N + E)</li> </ul>"},{"location":"Hard/3373%20Maximize%20the%20Number%20of%20Target%20Nodes%20After%20Connecting%20Trees%20II/#keywords","title":"Keywords","text":"<ul> <li>Graph</li> <li>Breadth-First Search (BFS)</li> <li>Tree</li> <li>Level traversal</li> </ul>"},{"location":"Hard/3373%20Maximize%20the%20Number%20of%20Target%20Nodes%20After%20Connecting%20Trees%20II/#code","title":"Code","text":"<pre><code>func maxTargetNodes(edges1 [][]int, edges2 [][]int) []int {\n    buildTree := func(edges [][]int) map[int][]int {\n        tree := make(map[int][]int)\n        for _, e := range edges {\n            tree[e[0]], tree[e[1]] = append(tree[e[0]], e[1]), append(tree[e[1]], e[0])\n        }\n        return tree\n    }\n    tree1, tree2 := buildTree(edges1), buildTree(edges2)\n\n    getEvenSlice := func(tree map[int][]int) ([]bool, int, int) {\n        even, q, level, visited, evenCnt, oddCnt := make([]bool, len(tree)), []int{0}, 1, make([]bool, len(tree)), 1, 0\n        even[0], visited[0] = true, true\n        for len(q) != 0 {\n            popN := len(q)\n            for _, n := range q {\n                for _, next := range tree[n] {\n                    if visited[next] {\n                        continue\n                    }\n                    if level &amp; 1 == 0 {\n                        even[next], evenCnt = true, evenCnt + 1\n                    } else {\n                        oddCnt += 1\n                    }\n                    q, visited[next] = append(q, next), true\n                }\n            }\n            q, level = q[popN:], level + 1\n        }\n        return even, evenCnt, oddCnt\n    }\n    tree1Even, even1, odd1 := getEvenSlice(tree1)\n    _, even2, odd2 := getEvenSlice(tree2)\n    maxTree2 := max(even2, odd2)\n\n    ret := make([]int, len(tree1))\n    for i, v := range tree1Even {\n        if v {\n            ret[i] = even1 + maxTree2\n        } else {\n            ret[i] = odd1 + maxTree2\n        }\n    }\n\n    return ret\n}\n</code></pre>"},{"location":"Hard/3727%20Find%20the%20Count%20of%20Good%20Integers/","title":"3727. Find the Count of Good Integers","text":""},{"location":"Hard/3727%20Find%20the%20Count%20of%20Good%20Integers/#intuition","title":"Intuition","text":"<ol> <li>For a palindromic number, we only need to determine the first half of digits, as the second half is a mirror</li> <li>We need to handle odd and even length numbers differently</li> <li>We need to avoid counting duplicates when different digit combinations result in the same frequency pattern</li> <li>Leading zeros should be excluded from the count</li> </ol>"},{"location":"Hard/3727%20Find%20the%20Count%20of%20Good%20Integers/#approach","title":"Approach","text":"<ol> <li>Generate palindromic numbers by:<ul> <li>Only generating the first half (up to breakPoint)</li> <li>Mirroring the digits for the second half</li> <li>For odd length numbers, the middle digit is counted once</li> </ul> </li> <li>Use a frequency array to track digit counts and avoid duplicates:<ul> <li>Store the frequency of each digit (0-9) in a [10]int array</li> <li>Use this as a key in a map to avoid counting duplicate patterns</li> </ul> </li> <li>Calculate permutations for each valid pattern:<ul> <li>Use factorial to compute total possible arrangements</li> <li>Account for repeated digits by dividing by their factorials</li> <li>Handle leading zeros by subtracting invalid cases</li> </ul> </li> <li>Recursively generate all possible first halves and check:<ul> <li>If the resulting palindrome is divisible by k</li> <li>If we've seen this digit frequency pattern before</li> </ul> </li> </ol>"},{"location":"Hard/3727%20Find%20the%20Count%20of%20Good%20Integers/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(10^(n/2) * n)</li> <li>Space complexity: O(n)</li> </ul>"},{"location":"Hard/3727%20Find%20the%20Count%20of%20Good%20Integers/#keywords","title":"Keywords","text":"<ul> <li>Palindrome</li> <li>Combinatorics</li> <li>Recursion</li> <li>Permutation</li> <li>Factorial</li> </ul>"},{"location":"Hard/3727%20Find%20the%20Count%20of%20Good%20Integers/#code","title":"Code","text":"<pre><code>func countGoodIntegers(n int, k int) int64 {\n    cnt := int64(0)\n    number, record, breakPoint, fac := make([]rune, n), make(map[[10]int]bool), 0, make(map[int]int)\n    switch n &amp; 1 == 1 {\n    case true:\n        breakPoint = n / 2\n    case false:\n        breakPoint = n / 2 - 1\n    }\n    fac[0] = 1\n    for i := 1; i &lt;= n; i += 1 {\n        fac[i] = fac[i - 1] * i\n    }\n\n    getPalindromic := func(cur []rune) [10]int {\n        ret := [10]int{}\n        for i := 0; i &lt;= breakPoint; i += 1 {\n            cur[len(cur) - 1 - i] = cur[i]\n            ret[cur[i] - '0'] += 2\n        }\n        if n &amp; 1 == 1 {\n            ret[cur[breakPoint] - '0'] -= 1\n        }\n        return ret\n    }\n\n    countPermutations := func(rec [10]int) int {\n        total := fac[n]\n        for _, ii := range rec {\n            total /= fac[ii]\n        }\n        if rec[0] != 0 {\n            total -= ((total * fac[rec[0]] / n) / fac[rec[0] - 1])\n        }\n        return total\n    }\n\n    var recur func(cur []rune, i int, nextN rune)\n    recur = func(cur []rune, i int, nextN rune) {\n        if i &gt; breakPoint {\n            return\n        }\n        cur[i] = nextN\n        if i == breakPoint {\n            rec := getPalindromic(cur)\n            if _, exist := record[rec]; exist {\n                return\n            }\n            palindromicNumber, _ := strconv.Atoi(string(cur))\n            if palindromicNumber % k != 0 {\n                return\n            }\n            cnt, record[rec] = cnt + int64(countPermutations(rec)), true\n            return\n        }\n        for j := 0; j &lt;= 9; j += 1 {\n            recur(number, i + 1, rune('0' + j))\n        }\n    }\n\n    for i := 1; i &lt;= 9; i += 1 {\n        recur(number, 0, rune('0' + i))\n    }\n    return cnt\n}\n</code></pre>"},{"location":"Hard/4%20Median%20of%20Two%20Sorted%20Arrays/","title":"4. Median of Two Sorted Arrays","text":""},{"location":"Hard/4%20Median%20of%20Two%20Sorted%20Arrays/#intuition","title":"Intuition","text":"<p>The problem requires finding the median of two sorted arrays. The key insight is that we only need to merge the arrays until we reach the middle position(s) to find the median, rather than merging the entire arrays. This saves both time and space complexity.</p>"},{"location":"Hard/4%20Median%20of%20Two%20Sorted%20Arrays/#approach","title":"Approach","text":"<ol> <li>Create a new array <code>nums3</code> to store the merged elements up to the median position</li> <li>Use two pointers <code>i</code> and <code>j</code> to track positions in <code>nums1</code> and <code>nums2</code> respectively</li> <li>Compare elements from both arrays and add the smaller one to <code>nums3</code></li> <li>Continue this process until we reach the middle position(s)</li> <li>For odd length total, return the middle element</li> <li>For even length total, return average of two middle elements</li> </ol>"},{"location":"Hard/4%20Median%20of%20Two%20Sorted%20Arrays/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(m+n)</li> <li>Space complexity: O((m+n)/2)</li> </ul>"},{"location":"Hard/4%20Median%20of%20Two%20Sorted%20Arrays/#keywords","title":"Keywords","text":"<ul> <li>Two Pointers</li> <li>Merge Sort</li> <li>Median</li> </ul>"},{"location":"Hard/4%20Median%20of%20Two%20Sorted%20Arrays/#code","title":"Code","text":"<pre><code>func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {\n    m, n := len(nums1), len(nums2)\n    l := m+n\n    i, j := 0, 0\n    var nums3 []int\n    for i&lt;m &amp;&amp; j&lt;n &amp;&amp; (i+j)&lt;=(l/2) {\n        if nums1[i]&lt;nums2[j] {\n            nums3 = append(nums3, nums1[i])\n            i += 1\n        } else {\n            nums3 = append(nums3, nums2[j])\n            j += 1\n        }\n    }\n    for (i+j)&lt;=(l/2) &amp;&amp; i&lt;m {\n        nums3 = append(nums3, nums1[i])\n        i += 1\n    }\n    for (i+j)&lt;=(l/2) &amp;&amp; j&lt;n {\n        nums3 = append(nums3, nums2[j])\n        j += 1\n    }\n    length := len(nums3)\n    if l%2 == 0 {\n        return (float64(nums3[length-1])+float64(nums3[length-2]))/float64(2)\n    }\n    return float64(nums3[length-1])\n}\n</code></pre>"},{"location":"Hard/42%20Trapping%20Rain%20Water/","title":"42. Trapping Rain Water","text":""},{"location":"Hard/42%20Trapping%20Rain%20Water/#intuition","title":"Intuition","text":"<p>The key insight is that the amount of water trapped at any position depends on the minimum of the maximum heights on both sides. We can use two pointers approach to track the maximum heights from both ends and calculate the trapped water accordingly.</p>"},{"location":"Hard/42%20Trapping%20Rain%20Water/#approach","title":"Approach","text":"<ol> <li>Use two pointers (left and right) starting from both ends of the array</li> <li>Keep track of the maximum heights seen from both sides (minL and minR)</li> <li>Move the pointer pointing to the smaller height</li> <li>For each position:<ul> <li>If current height is greater than or equal to the maximum height seen so far, update the maximum</li> <li>Otherwise, add the difference between maximum height and current height to the result</li> </ul> </li> <li>Continue until left pointer meets right pointer</li> </ol>"},{"location":"Hard/42%20Trapping%20Rain%20Water/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(n)</li> <li>Space complexity: O(1)</li> </ul>"},{"location":"Hard/42%20Trapping%20Rain%20Water/#keywords","title":"Keywords","text":"<ul> <li>Two Pointers</li> </ul>"},{"location":"Hard/42%20Trapping%20Rain%20Water/#code","title":"Code","text":"<pre><code>func trap(height []int) int {\n    if len(height) &lt; 2 {\n        return 0\n    }\n    left, right, ret, minL, minR := 0, len(height) - 1, 0, math.MinInt, math.MinInt\n    for left &lt; right {\n        if height[left] &lt; height[right] {\n            if height[left] &gt;= minL {\n                minL = height[left]\n            } else {\n                ret += minL - height[left]\n            }\n            left += 1\n        } else {\n            if height[right] &gt;= minR {\n                minR = height[right]\n            } else {\n                ret += minR - height[right]\n            }\n            right -= 1\n        }\n    }\n    return ret\n}\n</code></pre>"},{"location":"Hard/44%20Wildcard%20Matching/","title":"44. Wildcard Matching","text":""},{"location":"Hard/44%20Wildcard%20Matching/#intuition","title":"Intuition","text":"<p>This problem can be solved using a greedy approach with two pointers. The key insight is to handle the '' character differently from other characters. When we encounter a '', we keep track of its position and the position in the string where we matched it, so we can try different matching lengths for the '*' if needed.</p>"},{"location":"Hard/44%20Wildcard%20Matching/#approach","title":"Approach","text":"<ol> <li>Use two pointers <code>ss</code> and <code>pp</code> to track positions in string <code>s</code> and pattern <code>p</code> respectively</li> <li>Keep track of the latest '' position (<code>latestStar</code>) and the position in string where we started matching this '' (<code>latestStarMatch</code>)</li> <li>For each character in string s:<ul> <li>If current characters match (same char or '?'), move both pointers forward</li> <li>If we see a '*', record its position and current string position, then move pattern pointer</li> <li>If characters don't match but we have a previous '', backtrack to try matching one more character with that ''</li> <li>If none of above works, return false</li> </ul> </li> <li>After processing string s, check if remaining pattern only contains '*'</li> </ol>"},{"location":"Hard/44%20Wildcard%20Matching/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(S*P)</li> <li>Space complexity: O(1)</li> </ul>"},{"location":"Hard/44%20Wildcard%20Matching/#keywords","title":"Keywords","text":"<ul> <li>Two Pointers</li> <li>Greedy Algorithm</li> <li>Pattern Matching</li> </ul>"},{"location":"Hard/44%20Wildcard%20Matching/#code","title":"Code","text":"<pre><code>func isMatch(s string, p string) bool {\n    ss, pp, latestStar, latestStarMatch := 0, 0, -1, 0\n\n    for ss &lt; len(s) {\n        if pp &lt; len(p) &amp;&amp; (p[pp] == '?' || p[pp] == s[ss]) {\n            ss, pp = ss+1, pp+1\n        } else if pp &lt; len(p) &amp;&amp; p[pp] == '*' {\n            latestStar, latestStarMatch, pp = pp, ss, pp+1\n        } else if latestStar != -1 {\n            pp, latestStarMatch, ss = latestStar+1, latestStarMatch+1, latestStarMatch+1\n        } else {\n            return false\n        }\n    }\n\n    for pp &lt; len(p) &amp;&amp; p[pp] == '*' {\n        pp += 1\n    }\n    return pp == len(p)\n}\n</code></pre>"},{"location":"Hard/440%20K-th%20Smallest%20in%20Lexicographical%20Order/","title":"440. K-th Smallest in Lexicographical Order","text":""},{"location":"Hard/440%20K-th%20Smallest%20in%20Lexicographical%20Order/#intuition","title":"Intuition","text":"<p>This problem requires finding the k-th smallest number in lexicographical order from 1 to n. The key insight is that numbers in lexicographical order form a denary (base-10) trie structure. For example, numbers starting with 1 come before numbers starting with 2, and numbers starting with 10 come before numbers starting with 11.</p>"},{"location":"Hard/440%20K-th%20Smallest%20in%20Lexicographical%20Order/#approach","title":"Approach","text":"<ol> <li>We use a helper function <code>countPrefixNums</code> to count how many numbers with a given prefix exist within range [1, n].</li> <li>Start with prefix = 1 (smallest possible number).</li> <li>For each step:<ul> <li>Calculate how many numbers we can skip with current prefix</li> <li>If we can skip more numbers than k remaining, we go deeper by multiplying prefix by 10</li> <li>Otherwise, we move to next prefix by adding 1 and subtract skipped numbers from k</li> </ul> </li> <li>Continue this process until k becomes 0</li> </ol>"},{"location":"Hard/440%20K-th%20Smallest%20in%20Lexicographical%20Order/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(log n * log n)</li> <li>Space complexity: O(1)</li> </ul>"},{"location":"Hard/440%20K-th%20Smallest%20in%20Lexicographical%20Order/#keywords","title":"Keywords","text":"<ul> <li>Trie</li> <li>Lexicographical Order</li> <li>Prefix Counting</li> <li>Math</li> </ul>"},{"location":"Hard/440%20K-th%20Smallest%20in%20Lexicographical%20Order/#code","title":"Code","text":"<pre><code>func findKthNumber(n int, k int) int {\n    countPrefixNums := func(prefix int) int {\n        cur, next, ret := prefix, prefix + 1, 0\n        for cur &lt;= n {\n            ret += min(n + 1, next) - cur\n            cur, next = cur * 10, next * 10\n        }\n        return ret\n    }\n\n    ret := 1\n    k -= 1\n    for k &gt; 0 {\n        skipNums := countPrefixNums(ret)\n        if skipNums &lt;= k {\n            k, ret = k - skipNums, ret + 1\n        } else {\n            k, ret = k - 1, ret * 10\n        }\n    }\n    return ret\n}\n</code></pre>"},{"location":"Hard/460%20LFU%20Cache/","title":"460. LFU Cache","text":""},{"location":"Hard/460%20LFU%20Cache/#intuition","title":"Intuition","text":"<p>The implementation combines a doubly linked list with hash maps to create an LFU (Least Frequently Used) cache. The main ideas are:</p> <ol> <li>Use a hash map <code>storage</code> to map keys to nodes</li> <li>Use a hash map <code>freqMap</code> to map frequencies to their corresponding frequency lists</li> <li>Each frequency list uses a doubly linked list to store nodes with the same access frequency</li> </ol>"},{"location":"Hard/460%20LFU%20Cache/#approach","title":"Approach","text":"<p>The implementation consists of several key components:</p> <ol> <li> <p><code>Get</code> operation:</p> <ul> <li>If key doesn't exist, return -1</li> <li>If key exists, move the node to the next frequency list and return its value</li> </ul> </li> <li> <p><code>Put</code> operation:</p> <ul> <li>If key exists, update value and increase frequency</li> <li>If key doesn't exist:<ul> <li>If capacity not reached, add to frequency-1 list</li> <li>If capacity reached, remove the first node (earliest) from the lowest frequency list, then add new node</li> </ul> </li> </ul> </li> <li> <p>Frequency list operations:</p> <ul> <li><code>freqDelete</code>: Remove a node from a specific frequency list</li> <li><code>freqAdd</code>: Add a node to a specific frequency list</li> <li><code>moveToNextFreq</code>: Move a node to the next higher frequency list</li> </ul> </li> </ol>"},{"location":"Hard/460%20LFU%20Cache/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(1)</li> <li>Space complexity: O(capacity)</li> </ul>"},{"location":"Hard/460%20LFU%20Cache/#keywords","title":"Keywords","text":"<ul> <li>LFU Cache</li> <li>Double Linked List</li> <li>Hash Map</li> <li>Frequency Counter</li> <li>Cache Implementation</li> </ul>"},{"location":"Hard/460%20LFU%20Cache/#code","title":"Code","text":"<pre><code>type node struct {\n    key int\n    val int\n    freq int\n    prev *node\n    next *node\n}\n\ntype frequence struct {\n    head *node\n    tail *node\n}\n\nfunc newFreq() *frequence {\n    return &amp;frequence {\n        head: nil,\n        tail: nil,\n    }\n}\n\nfunc (f *frequence) freqDelete(n *node) {\n    if f.head == n {\n        if f.tail == n {\n            f.head, f.tail = nil, nil\n        } else {\n            headNext := f.head.next\n            headNext.prev = nil\n            f.head = headNext\n        }\n        n.prev, n.next = nil, nil\n        return\n    }\n    if f.tail == n {\n        tailPrev := f.tail.prev\n        tailPrev.next = nil\n        f.tail = tailPrev\n        n.prev, n.next = nil, nil\n        return\n    }\n    nPrev, nNext := n.prev, n.next\n    nPrev.next, nNext.prev = nNext, nPrev\n    n.prev, n.next = nil, nil\n}\n\nfunc (f *frequence) freqAdd(n *node) {\n    if f.head == nil {\n        f.head, f.tail = n, n\n        n.prev, n.next = nil, nil\n        return\n    }\n    n.prev, n.next = f.tail, nil\n    f.tail.next = n\n    f.tail = n\n}\n\ntype LFUCache struct {\n    cap int\n    size int\n    storage map[int]*node\n    freqMap map[int]*frequence\n}\n\n\nfunc Constructor(capacity int) LFUCache {\n    l := LFUCache {\n        cap: capacity,\n        size: 0,\n        storage: make(map[int]*node),\n        freqMap: make(map[int]*frequence),\n    }\n    l.freqMap[1] = newFreq()\n    return l\n}\n\nfunc (l *LFUCache) moveToNextFreq(n *node) {\n    l.freqMap[n.freq].freqDelete(n)\n    n.freq += 1\n    if _, ok := l.freqMap[n.freq]; !ok {\n        l.freqMap[n.freq] = newFreq()\n    }\n    l.freqMap[n.freq].freqAdd(n)\n}\n\nfunc (l *LFUCache) getLF() (int, *node) {\n    for i := 1; i &lt;= len(l.freqMap); i += 1 {\n        if l.freqMap[i].head != nil {\n            return i, l.freqMap[i].head\n        }\n    }\n    return -1, nil\n}\n\nfunc (l *LFUCache) Get(key int) int {\n    if _, ok := l.storage[key]; !ok {\n        return -1\n    }\n    l.moveToNextFreq(l.storage[key])\n    return l.storage[key].val\n}\n\n\nfunc (l *LFUCache) Put(key int, value int)  {\n    if n, ok := l.storage[key]; ok {\n        n.val = value\n        l.moveToNextFreq(n)\n        return\n    }\n    n := node{\n        key: key,\n        val: value,\n        freq: 1,\n        prev: nil,\n        next: nil,\n    }\n    l.storage[key] = &amp;n\n    if l.size &lt; l.cap {\n        l.freqMap[1].freqAdd(&amp;n)\n        l.size += 1\n        return\n    }\n    f, deleteNode := l.getLF()\n    l.freqMap[f].freqDelete(deleteNode)\n    l.freqMap[1].freqAdd(&amp;n)\n    delete(l.storage, deleteNode.key)\n}\n\n\n/**\n * Your LFUCache object will be instantiated and called as such:\n * obj := Constructor(capacity);\n * param_1 := obj.Get(key);\n * obj.Put(key,value);\n */\n</code></pre>"},{"location":"Hard/51%20N-Queens/","title":"51. N-Queens","text":""},{"location":"Hard/51%20N-Queens/#intuition","title":"Intuition","text":"<p>The key insight is that queens can attack horizontally, vertically, and diagonally. We need to ensure that no two queens share the same row, column, or diagonal.</p>"},{"location":"Hard/51%20N-Queens/#approach","title":"Approach","text":"<ol> <li>Use backtracking to explore all possible queen placements</li> <li>Maintain three sets to track occupied rows, columns, and diagonals</li> <li>For each row, try placing a queen in each column if it's safe</li> <li>If a valid placement is found, recursively try the next row</li> <li>If we reach the last row successfully, add the current board configuration to the result</li> <li>Backtrack by removing the last placed queen and try the next position</li> </ol>"},{"location":"Hard/51%20N-Queens/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(N!)</li> <li>Space complexity: O(N)</li> </ul>"},{"location":"Hard/51%20N-Queens/#keywords","title":"Keywords","text":"<ul> <li>Backtracking</li> <li>Recursion</li> <li>N-Queens</li> <li>DFS</li> </ul>"},{"location":"Hard/51%20N-Queens/#code","title":"Code","text":"<pre><code>func solveNQueens(n int) [][]string {\n    ret, board, queens := make([][]string, 0), make([]string, n), make([][2]int, 0)\n    row := \"\"\n    for i := 0; i &lt; n; i += 1 {\n        row += \".\"\n    }\n    for i := range board {\n        board[i] = row\n    }\n    rowMap, colMap := make(map[int]bool, n), make(map[int]bool, n)\n    var checkq func(i, j int) bool\n    var replaceQ func(i, j int)\n    var revertQ func(i, j int)\n    var recursion func(level int)\n    checkq = func(i, j int) bool {\n        for _, queen := range queens {\n            if math.Abs(float64(queen[0] - i) / float64(queen[1] - j)) == 1 {\n                return false\n            }\n        }\n        return true\n    }\n    replaceQ = func(i, j int) {\n        tmp := []byte(board[i])\n        tmp[j] = 'Q'\n        board[i] = string(tmp)\n    }\n    revertQ = func(i, j int) {\n        tmp := []byte(board[i])\n        tmp[j] = '.'\n        board[i] = string(tmp)\n    }\n    recursion = func(level int) {\n        for i := 0; i &lt; n; i += 1 {\n            if !rowMap[level] &amp;&amp; !colMap[i] &amp;&amp; checkq(level, i) {\n                replaceQ(level, i)\n                rowMap[level], colMap[i] = true, true\n                queens = append(queens, [2]int{level, i})\n                if level == n - 1 {\n                    ret = append(ret, append([]string{}, board...))\n                } else {\n                    recursion(level + 1)\n                }\n                revertQ(level, i)\n                rowMap[level], colMap[i] = false, false\n                queens = queens[: len(queens) - 1]\n            }\n        }\n    }\n    recursion(0)\n    return ret\n}\n</code></pre>"},{"location":"Hard/685%20Redundant%20Connection%20II/","title":"685. Redundant Connection II","text":""},{"location":"Hard/685%20Redundant%20Connection%20II/#intuition","title":"Intuition","text":"<p>The problem requires us to find a redundant edge in a directed graph that causes either a cycle or a node with two parents. The key insight is that there are two possible cases:</p> <ol> <li>A node has two parents (in-degree &gt; 1)</li> <li>The graph contains a cycle</li> </ol>"},{"location":"Hard/685%20Redundant%20Connection%20II/#approach","title":"Approach","text":"<ol> <li>First, we identify if there's a node with two parents by tracking the parent of each node. If found, we store the two candidate edges.</li> <li>We use Union-Find (Disjoint Set Union) to detect cycles in the graph.</li> <li>We process all edges except the second candidate edge (if it exists).</li> <li>If we find a cycle:<ul> <li>If we had a node with two parents, return the first candidate edge</li> <li>Otherwise, return the current edge that forms the cycle</li> </ul> </li> <li>If no cycle is found, return the second candidate edge (which must be the redundant one)</li> </ol>"},{"location":"Hard/685%20Redundant%20Connection%20II/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(n)</li> <li>Space complexity: O(n)</li> </ul>"},{"location":"Hard/685%20Redundant%20Connection%20II/#keywords","title":"Keywords","text":"<ul> <li>Union-Find</li> <li>Graph</li> <li>Cycle Detection</li> </ul>"},{"location":"Hard/685%20Redundant%20Connection%20II/#code","title":"Code","text":"<pre><code>func findRedundantDirectedConnection(edges [][]int) []int {\n    parent, candidate1, candidate2 := make(map[int]int), -1, -1\n    for i, edge := range edges {\n        if ii, found := parent[edge[1]]; found {\n            candidate1, candidate2 = ii, i\n            break\n        }\n        parent[edge[1]] = i\n    }\n\n    root := make([]int, len(edges) + 1)\n    for i := range root {\n        root[i] = i\n    }\n\n    findRoot := func(n int) int {\n        for root[n] != n {\n            root[n] = root[root[n]]\n            n = root[n]\n        }\n        return n\n    }\n\n    for _, edge := range edges {\n        u, v := edge[0], edge[1]\n        if candidate2 != -1 &amp;&amp; u == edges[candidate2][0] &amp;&amp; v == edges[candidate2][1] {\n            continue\n        }\n\n        ur, uv := findRoot(u), findRoot(v)\n\n        if ur == uv {\n            if candidate1 != -1 {\n                return edges[candidate1]\n            }\n            return edge\n        }\n        root[uv] = ur\n    }\n\n    return edges[candidate2]\n}\n</code></pre>"},{"location":"Hard/757%20Set%20Intersection%20Size%20At%20Least%20Two/","title":"757. Set Intersection Size At Least Two","text":""},{"location":"Hard/757%20Set%20Intersection%20Size%20At%20Least%20Two/#intuition","title":"Intuition","text":"<p>The key insight is to greedily select elements that can satisfy multiple intervals simultaneously. By sorting intervals by their end points, we can process them in an order that allows us to make optimal choices.</p>"},{"location":"Hard/757%20Set%20Intersection%20Size%20At%20Least%20Two/#approach","title":"Approach","text":"<ol> <li>Sort the intervals by their end points. If two intervals have the same end point, sort them by their start points in descending order (larger start point first).</li> <li>Initialize variables to track the two most recently added elements to our set S and the size of S.</li> <li>Iterate through the sorted intervals:<ul> <li>If the current interval doesn't overlap with our existing elements (prevEnd &lt; start), add the two largest possible elements from this interval (end-1 and end).</li> <li>If the current interval partially overlaps (prevStart &lt; start \u2264 prevEnd), we need to add one more element (the end of the current interval).</li> <li>If the current interval fully contains our existing elements (start \u2264 prevStart), we don't need to add any new elements.</li> </ul> </li> <li>Return the total size of set S.</li> </ol>"},{"location":"Hard/757%20Set%20Intersection%20Size%20At%20Least%20Two/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(NlogN)</li> <li>Space complexity: O(logN)</li> </ul>"},{"location":"Hard/757%20Set%20Intersection%20Size%20At%20Least%20Two/#keywords","title":"Keywords","text":"<ul> <li>Greedy Algorithm</li> <li>Interval Problems</li> <li>Sorting</li> </ul>"},{"location":"Hard/757%20Set%20Intersection%20Size%20At%20Least%20Two/#code","title":"Code","text":"<pre><code>func intersectionSizeTwo(intervals [][]int) int {\n    sort.Slice(intervals, func(i, j int) bool {\n        if intervals[i][1] == intervals[j][1] {\n            return intervals[i][0] &gt; intervals[j][0]\n        }\n        return intervals[i][1] &lt; intervals[j][1]\n    })\n\n    prevStart, prevEnd, ret := -1, -1, 0\n    for _, interval := range intervals {\n        start, end := interval[0], interval[1]\n\n        if prevEnd &lt; start {\n            prevStart, prevEnd = end - 1, end\n            ret += 2\n            continue\n        }\n        if prevStart &lt; start &amp;&amp; start &lt;= prevEnd {\n            prevStart, prevEnd = prevEnd, end\n            ret += 1\n        }\n    }\n\n    return ret\n}\n</code></pre>"},{"location":"Hard/765%20Couples%20Holding%20Hands/","title":"765. Couples Holding Hands","text":""},{"location":"Hard/765%20Couples%20Holding%20Hands/#intuition","title":"Intuition","text":"<p>Each time we need to find the correct \"couple\" pair for <code>2n</code> and <code>2n+1</code> seats, i = 1, 2, 3, ... .</p>"},{"location":"Hard/765%20Couples%20Holding%20Hands/#approach","title":"Approach","text":"<p>The solution uses a greedy algorithm with the following steps:</p> <ol> <li> <p>First, create a hash map <code>idToIndex</code> to record each person's seat index for efficient lookup and swapping operations.</p> </li> <li> <p>Examine adjacent seats from left to right (step size of 2):</p> <ul> <li>Get person <code>a</code> in the first seat and person <code>b</code> in the second seat</li> <li>Calculate who should be a's partner (expectB):<ul> <li>If a is even, their partner is a+1</li> <li>If a is odd, their partner is a-1</li> </ul> </li> </ul> </li> <li> <p>If b is not a's partner:</p> <ul> <li>Find the position of a's partner (expectB)</li> <li>Swap b with expectB</li> <li>Update the indices in the hash map</li> <li>Increment the swap counter</li> </ul> </li> <li> <p>Return the total number of swaps</p> </li> </ol>"},{"location":"Hard/765%20Couples%20Holding%20Hands/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(n)</li> <li>Space complexity: O(n)</li> </ul>"},{"location":"Hard/765%20Couples%20Holding%20Hands/#keywords","title":"Keywords","text":"<ul> <li>Greedy Algorithm</li> <li>Hash</li> </ul>"},{"location":"Hard/765%20Couples%20Holding%20Hands/#code","title":"Code","text":"<pre><code>func minSwapsCouples(row []int) int {\n    ret, idToIndex := 0, make(map[int]int)\n    for i, id := range row {\n        idToIndex[id] = i\n    }\n    for i := 0; i &lt; len(row); i += 2 {\n        a, b, expectB := row[i], row[i + 1], 0\n        if a &amp; 1 == 0 {\n            expectB = a + 1\n        } else {\n            expectB = a - 1\n        }\n        if b == expectB {\n            continue\n        }\n        indexB, indexExpectB := idToIndex[b], idToIndex[expectB]\n        row[indexB], row[indexExpectB], idToIndex[b], idToIndex[expectB] = row[indexExpectB], row[indexB], indexExpectB, indexB\n        ret += 1\n    }\n    return ret\n}\n</code></pre>"},{"location":"Hard/815%20Bus%20Routes/","title":"815 Bus Routes","text":""},{"location":"Hard/815%20Bus%20Routes/#intuition","title":"Intuition","text":"<p>The problem can be modeled as a graph where:</p> <ul> <li>Each bus route represents a set of connected stops</li> <li>We need to find the minimum number of bus changes required to go from source to target</li> <li>We can use BFS to explore all possible routes level by level, where each level represents one bus change</li> </ul>"},{"location":"Hard/815%20Bus%20Routes/#approach","title":"Approach","text":"<ol> <li>First check if source and target are the same (return 0 if true)</li> <li>Create a map <code>stopToBus</code> to store which buses stop at each station</li> <li>Use BFS to explore all possible routes:<ul> <li>Start from the source stop</li> <li>For each stop, check all buses that pass through it</li> <li>For each bus, check all stops it can reach</li> <li>If we reach the target, return the current number of bus changes</li> <li>Keep track of visited stops and buses to avoid cycles</li> </ul> </li> <li>If we exhaust all possibilities without finding the target, return -1</li> </ol>"},{"location":"Hard/815%20Bus%20Routes/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(N + M), where N is the number of stops and M is the number of bus routes</li> <li>Space complexity: O(N + M)</li> </ul>"},{"location":"Hard/815%20Bus%20Routes/#keywords","title":"Keywords","text":"<ul> <li>BFS</li> <li>Graph</li> </ul>"},{"location":"Hard/815%20Bus%20Routes/#code","title":"Code","text":"<pre><code>func numBusesToDestination(routes [][]int, source int, target int) int {\n    if source == target {\n        return 0\n    }\n    ret, n, stopToBus := 0, 0, make(map[int][]int)\n    for i, route := range routes {\n        for _, stop := range route {\n            stopToBus[stop] = append(stopToBus[stop], i)\n        }\n    }\n\n    queue, stopRecord, busRecord := []int{source}, map[int]bool{source: true}, make(map[int]bool)\n    bfs := func(curStop int) bool {\n        for _, bus := range stopToBus[curStop] {\n            if busRecord[bus] {\n                continue\n            }\n            busRecord[bus] = true\n            for _, stop := range routes[bus] {\n                if stopRecord[stop] {\n                    continue\n                }\n                if stop == target {\n                    return true\n                }\n                queue, stopRecord[stop] = append(queue, stop), true\n            }\n        }\n        return false\n    }\n    for len(queue) != 0 {\n        ret, n = ret + 1, len(queue)\n        for _, curStop := range queue {\n            if bfs(curStop) {\n                return ret\n            }\n        }\n        queue = queue[n:]\n    }\n\n    return -1\n}\n</code></pre>"},{"location":"Hard/834%20Sum%20of%20Distances%20in%20Tree/","title":"834. Sum of Distances in Tree","text":""},{"location":"Hard/834%20Sum%20of%20Distances%20in%20Tree/#intuition","title":"Intuition","text":"<p>A key observation is that we can leverage the tree structure and parent-child relationships to compute these sums efficiently. Instead of calculating distances from scratch for each node, we can use the results from a parent node to derive the results for its children.</p>"},{"location":"Hard/834%20Sum%20of%20Distances%20in%20Tree/#approach","title":"Approach","text":"<p>The solution uses a two-pass DFS approach:</p> <ol> <li>First DFS (dfs1):<ul> <li>Calculates the number of child nodes for each node</li> <li>Computes the initial sum of distances for the root node (0)</li> <li>This pass builds the foundation for the second pass</li> </ul> </li> <li>Second DFS (dfs2):<ul> <li>Uses the results from the first pass to compute distances for all other nodes</li> <li>For each child node, the sum of distances can be derived from its parent's sum using the formula:     <code>ret[child] = ret[parent] + (n - 2 * childNodes[child])</code></li> <li>This formula works because moving from parent to child:<ul> <li>Increases distance by 1 for all nodes not in the child's subtree</li> <li>Decreases distance by 1 for all nodes in the child's subtree</li> </ul> </li> </ul> </li> </ol>"},{"location":"Hard/834%20Sum%20of%20Distances%20in%20Tree/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(n)</li> <li>Space complexity: O(n)</li> </ul>"},{"location":"Hard/834%20Sum%20of%20Distances%20in%20Tree/#keywords","title":"Keywords","text":"<ul> <li>DFS</li> <li>Distance Calculation</li> </ul>"},{"location":"Hard/834%20Sum%20of%20Distances%20in%20Tree/#code","title":"Code","text":"<pre><code>func sumOfDistancesInTree(n int, edges [][]int) []int {\n    ret, childNodes, tree := make([]int, n), make([]int, n), make([][]int, n)\n    for _, edge := range edges {\n        a, b := edge[0], edge[1]\n        tree[a], tree[b] = append(tree[a], b), append(tree[b], a)\n    }\n\n    var dfs1 func(cur, prev int)\n    dfs1 = func(cur, prev int) {\n        childNodes[cur] = 1\n        for _, neighbor := range tree[cur] {\n            if neighbor == prev {\n                continue\n            }\n            dfs1(neighbor, cur)\n            childNodes[cur] += childNodes[neighbor]\n            ret[cur] += ret[neighbor] + childNodes[neighbor]\n        }\n    }\n\n    var dfs2 func(cur, prev int)\n    dfs2 = func(cur, prev int) {\n        for _, neighbor := range tree[cur] {\n            if neighbor == prev {\n                continue\n            }\n            ret[neighbor] = ret[cur] + (n- 2 * childNodes[neighbor])\n            dfs2(neighbor, cur)\n        }\n    }\n\n    dfs1(0, -1)\n    dfs2(0, -1)\n\n    return ret\n}\n</code></pre>"},{"location":"Hard/847%20Shortest%20Path%20Visiting%20All%20Nodes/","title":"847. Shortest Path Visiting All Nodes","text":""},{"location":"Hard/847%20Shortest%20Path%20Visiting%20All%20Nodes/#intuition","title":"Intuition","text":"<p>The problem requires finding the shortest path that visits all nodes in an undirected graph. We can think of this as a state-based BFS problem where each state consists of:</p> <ol> <li>The current node we're at</li> <li>A bitmask representing which nodes we've visited so far</li> </ol>"},{"location":"Hard/847%20Shortest%20Path%20Visiting%20All%20Nodes/#approach","title":"Approach","text":"<ol> <li>Use BFS to explore all possible paths while keeping track of visited states</li> <li>Each state is represented by a combination of:<ul> <li>Current node position</li> <li>Bitmask indicating visited nodes (1 &lt;&lt; i for node i)</li> </ul> </li> <li>Initialize the queue with all possible starting nodes</li> <li>For each state, explore all neighboring nodes</li> <li>Use a visited map to avoid revisiting the same state</li> <li>The target is reached when all nodes are visited (bitmask equals 2^n - 1)</li> </ol>"},{"location":"Hard/847%20Shortest%20Path%20Visiting%20All%20Nodes/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(n * 2^n)</li> <li>Space complexity: O(n * 2^n)</li> </ul>"},{"location":"Hard/847%20Shortest%20Path%20Visiting%20All%20Nodes/#keywords","title":"Keywords","text":"<ul> <li>BFS</li> <li>Bitmask</li> <li>State-based Search</li> <li>Graph Traversal</li> <li>Shortest Path</li> </ul>"},{"location":"Hard/847%20Shortest%20Path%20Visiting%20All%20Nodes/#code","title":"Code","text":"<pre><code>func shortestPathLength(graph [][]int) int {\n    if len(graph) == 1 {\n        return 0\n    }\n\n    type unit struct {\n        n int\n        mask int\n    }\n    newUnit := func(i, m int) *unit {\n        return &amp;unit{\n            n: i,\n            mask: m,\n        }\n    }\n\n    visited := make([]map[int]bool, len(graph))\n    queue := make([]*unit, 0)\n    for i := range graph {\n        mask := 1 &lt;&lt; i\n        visited[i] = make(map[int]bool)\n        queue = append(queue, newUnit(i, mask))\n    }\n\n    target, ret := 1 &lt;&lt; len(graph) - 1, 1\n    for {\n        n := len(queue)\n        for _, cur := range queue {\n            for _, nb := range graph[cur.n] {\n                nextMask := cur.mask | (1 &lt;&lt; nb)\n                if !visited[nb][nextMask] {\n                    if nextMask == target {\n                        goto RETURN\n                    }\n                    visited[nb][nextMask], queue = true, append(queue, newUnit(nb, nextMask))\n                }\n            }\n        }\n        queue, ret = queue[n:], ret + 1\n    }\n\nRETURN:\n    return ret\n}\n</code></pre>"},{"location":"Hard/887%20Super%20Egg%20Drop/","title":"887. Super Egg Drop","text":""},{"location":"Hard/887%20Super%20Egg%20Drop/#intuition","title":"Intuition","text":"<p>The traditional approach using dynamic programming with states (eggs, floors) leads to O(K*N\u00b2) complexity, which is too slow. Instead, we can reformulate the problem: if we have K eggs and can make M moves, what's the maximum number of floors we can cover?</p>"},{"location":"Hard/887%20Super%20Egg%20Drop/#approach","title":"Approach","text":"<p>For each move, we have two possibilities when dropping an egg from a floor:</p> <ol> <li>The egg breaks, so we can only use K-1 eggs for floors below</li> <li>The egg doesn't break, so we can use K eggs for floors above</li> </ol> <p>We use a mathematical recursion to calculate the maximum floors we can cover with K eggs and M moves:</p> <ul> <li>Let maxFloor[i] represent the maximum number of floors that can be determined with i eggs and current number of moves</li> <li>For each move, we update maxFloor[i] = 1 + maxFloor[i-1] + maxFloor[i]<ul> <li>maxFloor[i-1]: floors covered if egg breaks</li> <li>maxFloor[i]: floors covered if egg doesn't break</li> <li>+1: the current floor we're dropping from</li> </ul> </li> </ul> <p>We keep increasing the number of moves until the maximum floor we can check is greater than or equal to N.</p>"},{"location":"Hard/887%20Super%20Egg%20Drop/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(K log N)</li> <li>Space complexity: O(K)</li> </ul>"},{"location":"Hard/887%20Super%20Egg%20Drop/#keywords","title":"Keywords","text":"<ul> <li>Dynamic Programming</li> </ul>"},{"location":"Hard/887%20Super%20Egg%20Drop/#code","title":"Code","text":"<pre><code>func superEggDrop(k int, n int) int {\n    maxFloor := make([]int, k + 1)\n    m := 0\n    for ; maxFloor[k] &lt; n; m += 1 {\n        for i := k; i &gt; 0; i -= 1 {\n            maxFloor[i] = 1 + maxFloor[i - 1] + maxFloor[i]\n        }\n    }\n    return m\n}\n</code></pre>"},{"location":"Hard/895%20Maximum%20Frequency%20Stack/","title":"895. Maximum Frequency Stack","text":""},{"location":"Hard/895%20Maximum%20Frequency%20Stack/#intuition","title":"Intuition","text":"<p>The problem requires us to implement a stack-like data structure that can track the frequency of elements and pop the most frequent element. When multiple elements have the same frequency, we need to pop the one that was pushed most recently. The key insight is to maintain a frequency map and a stack of stacks, where each inner stack contains elements of the same frequency.</p>"},{"location":"Hard/895%20Maximum%20Frequency%20Stack/#approach","title":"Approach","text":"<ol> <li>Use a <code>freqMap</code> to track the frequency of each element</li> <li>Use a <code>freqStack</code> which is a 2D slice where:<ul> <li>Each inner slice represents elements of the same frequency</li> <li>The index of the inner slice represents the frequency level</li> <li>Elements in the same inner slice maintain their push order</li> </ul> </li> <li>For Push operation:<ul> <li>If element is new or has frequency -1, add it to frequency level 0</li> <li>Otherwise, increment its frequency and add it to the corresponding level</li> </ul> </li> <li>For Pop operation:<ul> <li>Remove the last element from the highest frequency level</li> <li>Decrement its frequency in the map</li> <li>Remove the frequency level if it becomes empty</li> </ul> </li> </ol>"},{"location":"Hard/895%20Maximum%20Frequency%20Stack/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(1)</li> <li>Space complexity: O(n)</li> </ul>"},{"location":"Hard/895%20Maximum%20Frequency%20Stack/#keywords","title":"Keywords","text":"<ul> <li>Stack</li> <li>Hash Map</li> </ul>"},{"location":"Hard/895%20Maximum%20Frequency%20Stack/#code","title":"Code","text":"<pre><code>type FreqStack struct {\n    freqMap map[int]int\n    freqStack [][]int\n}\n\n\nfunc Constructor() FreqStack {\n    f := FreqStack{\n        freqMap: make(map[int]int),\n        freqStack: make([][]int, 0),\n    }\n    f.freqStack = append(f.freqStack, make([]int, 0))\n    return f\n}\n\n\nfunc (f *FreqStack) Push(val int)  {\n    if level, found := f.freqMap[val]; !found || level == -1 {\n        f.freqStack[0], f.freqMap[val] = append(f.freqStack[0], val), 0\n    } else {\n        if len(f.freqStack) - 1 == level {\n            f.freqStack = append(f.freqStack, make([]int, 0))\n        }\n        f.freqStack[level + 1], f.freqMap[val] = append(f.freqStack[level + 1], val), level + 1\n    }\n}\n\n\nfunc (f *FreqStack) Pop() int {\n    tgt := f.freqStack[len(f.freqStack) - 1][len(f.freqStack[len(f.freqStack) - 1]) - 1]\n    f.freqStack[len(f.freqStack) - 1], f.freqMap[tgt] = f.freqStack[len(f.freqStack) - 1][: len(f.freqStack[len(f.freqStack) - 1]) - 1], f.freqMap[tgt] - 1\n    if len(f.freqStack[len(f.freqStack) - 1]) == 0 {\n        f.freqStack = f.freqStack[: len(f.freqStack) - 1]\n    }\n    return tgt\n}\n\n\n/**\n * Your FreqStack object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Push(val);\n * param_2 := obj.Pop();\n */\n</code></pre>"},{"location":"Medium/105%20Construct%20Binary%20Tree%20from%20Preorder%20and%20Inorder%20Tranversal/","title":"105. Construct Binary Tree from Preorder and Inorder Tranversal","text":""},{"location":"Medium/105%20Construct%20Binary%20Tree%20from%20Preorder%20and%20Inorder%20Tranversal/#intuition","title":"Intuition","text":"<p>The key insight is that we can use a stack to keep track of nodes we've seen in the preorder traversal. The inorder traversal helps us determine when we need to backtrack and create right subtrees. This approach allows us to build the tree in a single pass through the preorder array.</p>"},{"location":"Medium/105%20Construct%20Binary%20Tree%20from%20Preorder%20and%20Inorder%20Tranversal/#approach","title":"Approach","text":"<ol> <li>Create a stack to keep track of nodes</li> <li>Initialize the root node with the first element from preorder</li> <li>For each subsequent element in preorder:<ul> <li>If the current node's value doesn't match the inorder[idx], it's a left child</li> <li>If it matches, we need to backtrack up the stack until we find a mismatch, then create a right child</li> </ul> </li> <li>Use the inorder array to determine when to backtrack and create right subtrees</li> </ol>"},{"location":"Medium/105%20Construct%20Binary%20Tree%20from%20Preorder%20and%20Inorder%20Tranversal/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(n)</li> <li>Space complexity: O(h), h is the tree's height</li> </ul>"},{"location":"Medium/105%20Construct%20Binary%20Tree%20from%20Preorder%20and%20Inorder%20Tranversal/#keywords","title":"Keywords","text":"<ul> <li>Binary Tree</li> <li>Stack</li> <li>Tree Construction</li> <li>Preorder Traversal</li> <li>Inorder Traversal</li> </ul>"},{"location":"Medium/105%20Construct%20Binary%20Tree%20from%20Preorder%20and%20Inorder%20Tranversal/#code","title":"Code","text":"<pre><code>/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\ntype stack []interface{}\n\nfunc NewStack() *stack {\n    s := make(stack, 0)\n    return &amp;s\n}\n\nfunc (s *stack) Len() int {\n    return len(*s)\n}\n\nfunc (s *stack) IsEmpty() bool {\n    return s.Len() == 0\n}\n\nfunc (s *stack) Top() (interface{}, error) {\n    if s.IsEmpty() {\n        return nil, errors.New(\"Stack is empty.\")\n    }\n    return (*s)[s.Len()-1], nil\n}\n\nfunc (s *stack) Push(item interface{}) {\n    (*s) = append((*s), item)\n}\n\nfunc (s *stack) Pop() (interface{}, error) {\n    if s.IsEmpty() {\n        return nil, errors.New(\"Stack is empty.\")\n    }\n    top := (*s)[s.Len() - 1]\n    (*s) = (*s)[:s.Len() - 1]\n    return top, nil\n}\n\nfunc NewTreeNode(v int, l, r *TreeNode) *TreeNode {\n    return &amp;TreeNode{Val: v, Left: l, Right: r}\n}\nfunc buildTree(preorder []int, inorder []int) *TreeNode {\n    idx, st, root := 0, NewStack(), NewTreeNode(preorder[0], nil, nil)\n    st.Push(root)\n    for i := 1; i &lt; len(preorder); i += 1 {\n        num := preorder[i]\n        top, _ := st.Top()\n        if top.(*TreeNode).Val != inorder[idx] {\n            top.(*TreeNode).Left = NewTreeNode(num, nil, nil)\n            st.Push(top.(*TreeNode).Left)\n        } else {\n            for !st.IsEmpty() {\n                if tt, _ := st.Top(); tt.(*TreeNode).Val != inorder[idx] {\n                    break\n                }\n                top, _ = st.Pop()\n                idx += 1\n            }\n            top.(*TreeNode).Right = NewTreeNode(num, nil, nil)\n            st.Push(top.(*TreeNode).Right)\n        }\n    }\n    return root\n}\n</code></pre>"},{"location":"Medium/11%20Container%20With%20Most%20Water/","title":"11. Container With Most Water","text":""},{"location":"Medium/11%20Container%20With%20Most%20Water/#intuition","title":"Intuition","text":"<p>The key insight is that the area of water contained between two lines is determined by:</p> <ol> <li>The distance between the lines (width)</li> <li>The height of the shorter line (as water can only be contained up to the height of the shorter line)</li> </ol>"},{"location":"Medium/11%20Container%20With%20Most%20Water/#approach","title":"Approach","text":"<ol> <li>Use two pointers technique, starting from both ends of the array</li> <li>Calculate the area between the two pointers</li> <li>Move the pointer pointing to the shorter line inward, as this is the only way we might find a larger area</li> <li>Keep track of the maximum area found so far</li> </ol>"},{"location":"Medium/11%20Container%20With%20Most%20Water/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(n)</li> <li>Space complexity: O(1)</li> </ul>"},{"location":"Medium/11%20Container%20With%20Most%20Water/#keywords","title":"Keywords","text":"<ul> <li>Two Pointers</li> </ul>"},{"location":"Medium/11%20Container%20With%20Most%20Water/#code","title":"Code","text":"<pre><code>func maxArea(height []int) int {\n    l, r := 0, len(height) - 1\n    ret := math.MinInt\n    for l &lt; r {\n        ret = max(ret, (r - l) * min(height[l], height[r]))\n        if height[l] &lt; height[r] {\n            l += 1\n        } else {\n            r -= 1\n        }\n    }\n    return ret\n}\n</code></pre>"},{"location":"Medium/12%20Integer%20to%20Roman/","title":"12. Integer to Roman","text":""},{"location":"Medium/12%20Integer%20to%20Roman/#intuition","title":"Intuition","text":"<p>The key insight is that Roman numerals follow specific patterns and rules. We can break down any integer into its constituent parts using a greedy approach, starting from the largest possible Roman numeral value and working our way down.</p>"},{"location":"Medium/12%20Integer%20to%20Roman/#approach","title":"Approach","text":"<ol> <li>Create a mapping of integer values to their corresponding Roman numeral symbols, including special cases like 4 (IV), 9 (IX), etc.</li> <li>Start from the largest value (1000) and work down to the smallest (1)</li> <li>For each position:<ul> <li>If the current value exists in our mapping, use it directly</li> <li>Otherwise, handle it by combining the appropriate symbols:<ul> <li>For values \u2265 5, first add the 5-symbol (V, L, D) and then add the 1-symbol (I, X, C) as needed</li> <li>For values &lt; 5, add the 1-symbol repeatedly</li> </ul> </li> </ul> </li> <li>Continue this process until we've processed all digits</li> </ol>"},{"location":"Medium/12%20Integer%20to%20Roman/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(n)</li> <li>Space complexity: O(1)</li> </ul>"},{"location":"Medium/12%20Integer%20to%20Roman/#keywords","title":"Keywords","text":"<ul> <li>Hash Map</li> <li>String Manipulation</li> <li>Number System Conversion</li> </ul>"},{"location":"Medium/12%20Integer%20to%20Roman/#code","title":"Code","text":"<pre><code>func intToRoman(num int) string {\n    roman := map[int]string{\n        1: \"I\",\n        4: \"IV\",\n        5: \"V\",\n        9: \"IX\",\n        10: \"X\",\n        40: \"XL\",\n        50: \"L\",\n        90: \"XC\",\n        100: \"C\",\n        400: \"CD\",\n        500: \"D\",\n        900: \"CM\",\n        1000: \"M\",\n    }\n\n    ten, ret := 1000, \"\"\n    for num &gt; 0 {\n        cur := num / ten\n        if v, found := roman[cur * ten]; found {\n            ret += v\n        } else {\n            t := roman[ten]\n            if cur &gt;= 5 {\n                ret, cur = ret + roman[5 * ten], cur - 5\n            }\n            for ;cur &gt; 0; cur -= 1 {\n                ret += t\n            }\n        }\n        num, ten = num % ten, ten / 10\n    }\n    return ret\n}\n</code></pre>"},{"location":"Medium/1209%20Remove%20All%20Adjacent%20Duplicates%20in%20String%20II/","title":"1209. Remove All Adjacent Duplicates in String II","text":""},{"location":"Medium/1209%20Remove%20All%20Adjacent%20Duplicates%20in%20String%20II/#intuition","title":"Intuition","text":"<p>The problem requires us to remove k adjacent duplicate characters from a string. We can use a stack-based approach where we keep track of both the character and its count. When we encounter k consecutive same characters, we remove them from the stack.</p>"},{"location":"Medium/1209%20Remove%20All%20Adjacent%20Duplicates%20in%20String%20II/#approach","title":"Approach","text":"<ol> <li>Create a stack to store pairs of (character, count)</li> <li>Iterate through each character in the string:<ul> <li>If stack is empty, push the character with count 1</li> <li>If current character matches the top of stack:<ul> <li>Increment the count</li> <li>If count reaches k, pop the element from stack</li> </ul> </li> <li>If current character is different, push it with count 1</li> </ul> </li> <li>Finally, reconstruct the string from the stack by repeating each character according to its count</li> </ol>"},{"location":"Medium/1209%20Remove%20All%20Adjacent%20Duplicates%20in%20String%20II/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(n)</li> <li>Space complexity: O(n)</li> </ul>"},{"location":"Medium/1209%20Remove%20All%20Adjacent%20Duplicates%20in%20String%20II/#keywords","title":"Keywords","text":"<ul> <li>Stack</li> <li>String Manipulation</li> </ul>"},{"location":"Medium/1209%20Remove%20All%20Adjacent%20Duplicates%20in%20String%20II/#code","title":"Code","text":"<pre><code>func removeDuplicates(s string, k int) string {\n    type unit struct {\n        char rune\n        cnt int\n    }\n\n    st := make([]unit, 0)\n\n    for _, char := range s {\n        if len(st) == 0 {\n            st = append(st, unit{char: char, cnt: 1})\n            continue\n        }\n        if st[len(st) - 1].char == char {\n            st[len(st) - 1].cnt += 1\n            if st[len(st) - 1].cnt == k {\n                st = st[:len(st) - 1]\n            }\n            continue\n        }\n        st = append(st, unit{char: char, cnt: 1})\n    }\n\n    ret := \"\"\n    for _, u := range st {\n        for i := 0; i &lt; u.cnt; i += 1 {\n            ret += string(u.char)\n        }\n    }\n    return ret\n}\n</code></pre>"},{"location":"Medium/1395%20Count%20Number%20of%20Teams/","title":"1395 Count Number of Teams","text":""},{"location":"Medium/1395%20Count%20Number%20of%20Teams/#intuition","title":"Intuition","text":"<p>Use the \"simplest\" DP method to solve the problem. For each rating value, go \"finding\" how many numbers make me be the third member in the team and \"record\" how many numbers make be the middle member in the team.</p>"},{"location":"Medium/1395%20Count%20Number%20of%20Teams/#approach","title":"Approach","text":"<p>First, make two dp array for recording increase condition and decrease condition.</p> <p>Second, go through the rating array and check the numbers before the current index-i whether it is comply the rules, i.e. increase or decrease.</p> <p>Third, if true, the increase[j] / decrease[j] value means rating[i] will be the third member in these teams. So add it to the ret(urn) value. And also update the increase[i] / decrease[i] value, which means rating[j] and rating[j] will be the first and middle member of the team and waiting for the third member in the following round.</p>"},{"location":"Medium/1395%20Count%20Number%20of%20Teams/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(N^2)</li> <li>Space complexity: O(N)</li> </ul>"},{"location":"Medium/1395%20Count%20Number%20of%20Teams/#keywords","title":"Keywords","text":"<ul> <li>DP</li> </ul>"},{"location":"Medium/1395%20Count%20Number%20of%20Teams/#code","title":"Code","text":"<pre><code>func numTeams(rating []int) int {\n    ret, increase, decrease := 0, make([]int, len(rating)), make([]int, len(rating))\n    for i := 0; i &lt; len(rating); i += 1 {\n        for j := i - 1; j &gt;= 0; j -= 1 {\n            if rating[j] &lt; rating[i] {\n                ret, increase[i] = ret + increase[j], increase[i] + 1\n            }\n            if rating[j] &gt; rating[i] {\n                ret, decrease[i] = ret + decrease[j], decrease[i] + 1\n            }\n        }\n    }\n    return ret\n}\n</code></pre>"},{"location":"Medium/146%20LRU%20Cache/","title":"146. LRU Cache","text":""},{"location":"Medium/146%20LRU%20Cache/#intuition","title":"Intuition","text":"<p>The implementation uses a combination of a doubly linked list and a hash map to achieve O(1) operations. The doubly linked list maintains the order of elements (most recently used at head, least recently used at tail), while the hash map provides quick access to nodes.</p>"},{"location":"Medium/146%20LRU%20Cache/#approach","title":"Approach","text":"<p>The implementation consists of these key components:</p> <ol> <li> <p>Data Structures:</p> <ul> <li><code>node</code>: Doubly linked list node containing key, value, and pointers</li> <li><code>queue</code>: Custom doubly linked list with head and tail</li> <li><code>storage</code>: Hash map for O(1) lookup of nodes</li> </ul> </li> <li> <p>Queue Operations:</p> <ul> <li><code>insert</code>: Add new node at head (most recently used)</li> <li><code>delete</code>: Remove node from tail (least recently used)</li> <li><code>update</code>: Move existing node to head and update value</li> </ul> </li> <li> <p>Cache Operations:</p> <ul> <li> <p><code>Get</code>:</p> <ul> <li>If key exists: Update node position to head and return value</li> <li>If key doesn't exist: Return -1</li> </ul> </li> <li> <p><code>Put</code>:</p> <ul> <li>If key exists: Update value and move to head</li> <li>If key doesn't exist:<ul> <li>If capacity reached: Remove LRU (tail) and add new node at head</li> <li>If capacity not reached: Add new node at head</li> </ul> </li> </ul> </li> </ul> </li> </ol>"},{"location":"Medium/146%20LRU%20Cache/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(1)</li> <li>Space complexity: O(capacity)</li> </ul>"},{"location":"Medium/146%20LRU%20Cache/#keywords","title":"Keywords","text":"<ul> <li>LRU Cache</li> <li>Doubly Linked List</li> <li>Hash Map</li> </ul>"},{"location":"Medium/146%20LRU%20Cache/#code","title":"Code","text":"<pre><code>type node struct {\n    key int\n    val int\n    prev *node\n    next *node\n}\n\ntype queue struct {\n    head *node\n    tail *node\n}\n\nfunc (q *queue) insert(n *node) {\n    if q.head == nil {\n        q.head, q.tail = n, n\n        return\n    }\n    q.head.prev, n.next = n, q.head\n    q.head = n\n}\n\nfunc (q *queue) delete() {\n    if q.head == q.tail {\n        q.head, q.tail = nil, nil\n        return\n    }\n    prev := q.tail.prev\n    prev.next, q.tail = nil, prev\n}\n\nfunc (q *queue) update(n *node, val int) {\n    n.val = val\n    if q.head == n {\n        return\n    }\n    if q.tail == n {\n        prev := q.tail.prev\n        prev.next, q.tail, n.prev = nil, prev, nil\n\n        q.head.prev, n.next = n, q.head\n        q.head = n\n        return\n    }\n    prev, next := n.prev, n.next\n    n.prev, n.next, prev.next, next.prev, q.head.prev = nil, q.head, next, prev, n\n    q.head = n\n}\n\ntype LRUCache struct {\n    cap int\n    siz int\n    storage map[int]*node\n    q *queue\n}\n\n\nfunc Constructor(capacity int) LRUCache {\n    return LRUCache{\n        cap: capacity,\n        siz: 0,\n        storage: make(map[int]*node),\n        q: &amp;queue{\n            head: nil,\n            tail: nil,\n        },\n    }\n}\n\n\nfunc (l *LRUCache) Get(key int) int {\n    var ret int\n    if n, find := l.storage[key]; !find {\n        return -1\n    } else {\n        l.q.update(n, n.val)\n        ret = n.val\n    }\n    return ret\n}\n\n\nfunc (l *LRUCache) Put(key int, value int)  {\n    if n, find := l.storage[key]; find {\n        l.q.update(n, value)\n        return\n    }\n    n := &amp;node{\n        key: key,\n        val: value,\n        prev: nil,\n        next: nil,\n    }\n\n    if l.siz == l.cap {\n        delete(l.storage, l.q.tail.key)\n        l.q.delete()\n        l.siz -= 1\n    }\n    l.q.insert(n)\n    l.storage[key] = n\n    l.siz += 1\n}\n\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * obj := Constructor(capacity);\n * param_1 := obj.Get(key);\n * obj.Put(key,value);\n */\n</code></pre>"},{"location":"Medium/15%203Sum/","title":"15. 3Sum","text":""},{"location":"Medium/15%203Sum/#intuition","title":"Intuition","text":"<p>The key insight is to use a two-pointer approach after sorting the array. By sorting first, we can efficiently find all unique triplets that sum to zero while avoiding duplicates.</p>"},{"location":"Medium/15%203Sum/#approach","title":"Approach","text":"<ol> <li>Sort the array to enable the two-pointer technique</li> <li>Use three pointers: start, mid, and last</li> <li>For each start position:<ul> <li>Use mid and last pointers to find pairs that sum to -nums[start]</li> <li>Move mid forward if sum is too small</li> <li>Move last backward if sum is too large</li> </ul> </li> <li>Use a map to store unique triplets</li> <li>Convert the map keys back to the required return format</li> </ol>"},{"location":"Medium/15%203Sum/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(n\u00b2)</li> <li>Space complexity: O(n)</li> </ul>"},{"location":"Medium/15%203Sum/#keywords","title":"Keywords","text":"<ul> <li>Sorting</li> <li>Hash Map</li> </ul>"},{"location":"Medium/15%203Sum/#code","title":"Code","text":"<pre><code>func threeSum(nums []int) [][]int {\n    mp := make(map[[3]int]bool)\n    ret := make([][]int, 0)\n    sort.Ints(nums)\n\n    for start, mid, last := 0, 1, len(nums) - 1; start &lt; last; {\n        for mid &lt; last {\n            if nums[start] + nums[mid] + nums[last] == 0 {\n                mp[[3]int{nums[start], nums[mid], nums[last]}] = true\n                mid += 1\n                last -= 1\n            } else {\n                if nums[start] + nums[mid] + nums[last] &lt; 0 {\n                    mid += 1\n                } else {\n                    last -= 1\n                }\n            }\n        }\n        if mid &gt;= last {\n            start += 1\n            mid = start + 1\n            last = len(nums) - 1\n        }\n    }\n\n    for key := range mp {\n        ret = append(ret, []int{key[0], key[1], key[2]})\n    }\n    return ret\n}\n</code></pre>"},{"location":"Medium/16%203Sum%20Closest/","title":"16. 3Sum Closest","text":""},{"location":"Medium/16%203Sum%20Closest/#intuition","title":"Intuition","text":"<p>The problem is similar to 3Sum, but instead of finding exact matches, we need to find the sum that is closest to the target. We can use a similar two-pointer approach after sorting the array, but we'll need to keep track of the closest sum we've found so far.</p>"},{"location":"Medium/16%203Sum%20Closest/#approach","title":"Approach","text":"<ol> <li>Sort the array to enable the two-pointer technique</li> <li>Initialize the result with the sum of first three numbers</li> <li>For each number at index i:<ul> <li>Use two pointers (j and k) starting from i+1 and end of array</li> <li>Calculate the current sum of three numbers</li> <li>Update the result if current sum is closer to target</li> <li>Move pointers based on comparison with target:<ul> <li>If sum &lt; target, move left pointer right</li> <li>If sum &gt; target, move right pointer left</li> <li>If sum == target, return immediately as it's the closest possible</li> </ul> </li> </ul> </li> </ol>"},{"location":"Medium/16%203Sum%20Closest/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(n\u00b2)</li> <li>Space complexity: O(1)</li> </ul>"},{"location":"Medium/16%203Sum%20Closest/#keywords","title":"Keywords","text":"<ul> <li>Two Pointers</li> <li>Sorting</li> </ul>"},{"location":"Medium/16%203Sum%20Closest/#code","title":"Code","text":"<pre><code>func threeSumClosest(nums []int, target int) int {\n    abs := func(x int) int {\n        if x &lt; 0 {\n            return -x\n        }\n        return x\n    }\n    sort.Ints(nums)\n\n    ret := nums[0] + nums[1] + nums[2]\n    for i := 0; i &lt; len(nums) - 2; i += 1 {\n        j, k := i + 1, len(nums) - 1\n        for j &lt; k {\n            tmp := nums[i] + nums[j] + nums[k]\n            if abs(tmp - target) &lt; abs(ret - target) {\n                ret = tmp\n            }\n\n            if tmp &lt; target {\n                j += 1\n            } else if tmp &gt; target {\n                k -= 1\n            } else {\n                return tmp\n            }\n        }\n    }\n    return ret\n}\n</code></pre>"},{"location":"Medium/17%20Letter%20Combinations%20of%20a%20Phone%20Number/","title":"17. Letter Combinations of a Phone Number","text":""},{"location":"Medium/17%20Letter%20Combinations%20of%20a%20Phone%20Number/#intuition","title":"Intuition","text":"<p>The problem requires us to generate all possible letter combinations that could be represented by a given sequence of digits on a phone keypad. Each digit (2-9) maps to a set of letters, and we need to find all possible combinations by selecting one letter from each digit's corresponding set.</p>"},{"location":"Medium/17%20Letter%20Combinations%20of%20a%20Phone%20Number/#approach","title":"Approach","text":"<ol> <li>Create a hash map to store the mapping between digits and their corresponding letters</li> <li>Use a recursive approach to build combinations:<ul> <li>For each digit in the input string, try all possible letters mapped to that digit</li> <li>When we reach the last digit, add the complete combination to the result</li> <li>Use a byte slice to build combinations efficiently</li> <li>Pass a pointer to the result slice to avoid copying large slices</li> </ul> </li> </ol>"},{"location":"Medium/17%20Letter%20Combinations%20of%20a%20Phone%20Number/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(4^N * N)</li> <li>Space complexity: O(N)</li> </ul>"},{"location":"Medium/17%20Letter%20Combinations%20of%20a%20Phone%20Number/#keywords","title":"Keywords","text":"<ul> <li>Recursion</li> <li>Backtracking</li> <li>Hash Map</li> </ul>"},{"location":"Medium/17%20Letter%20Combinations%20of%20a%20Phone%20Number/#code","title":"Code","text":"<pre><code>func recursive(result []byte, idx int, ret *[]string, hash map[byte][]byte, digits string) {\n    if idx == len(result) - 1 {\n        for _, alph := range hash[digits[idx]] {\n            result[idx] = alph\n            *ret = append(*ret, string(result))\n        }\n        return\n    }\n    for _, alph := range hash[digits[idx]] {\n        result[idx] = alph\n        recursive(result, idx + 1, ret, hash, digits)\n    }\n}\n\nfunc letterCombinations(digits string) []string {\n    ret := make([]string, 0)\n    if digits == \"\" {\n        return ret\n    }\n    hash := map[byte][]byte{\n        '2': {'a', 'b', 'c'},\n        '3': {'d', 'e', 'f'},\n        '4': {'g', 'h', 'i'},\n        '5': {'j', 'k', 'l'},\n        '6': {'m', 'n', 'o'},\n        '7': {'p', 'q', 'r', 's'},\n        '8': {'t', 'u', 'v'},\n        '9': {'w', 'x', 'y', 'z'},\n    }\n    result := make([]byte, len([]byte(digits)))\n    recursive(result, 0, &amp;ret, hash, digits)\n    return ret\n}\n</code></pre>"},{"location":"Medium/2%20Add%20Two%20Numbers/","title":"2. Add Two Numbers","text":""},{"location":"Medium/2%20Add%20Two%20Numbers/#intuition","title":"Intuition","text":"<p>The problem requires adding two numbers represented by linked lists, where each digit is stored in reverse order. The key insight is to traverse both lists simultaneously while handling the carry-over value, similar to how we perform manual addition.</p>"},{"location":"Medium/2%20Add%20Two%20Numbers/#approach","title":"Approach","text":"<ol> <li>Create a helper struct <code>HL</code> (Headed List) to manage the result linked list, with methods to append nodes.</li> <li>Traverse both input linked lists simultaneously until both lists are exhausted and there's no remaining carry value.</li> <li>For each position:<ul> <li>Sum the digits from both lists (if available) and the carry value</li> <li>Calculate new carry value (sum / 10)</li> <li>Append the current digit (sum % 10) to result list</li> </ul> </li> <li>Return the head of the resulting linked list</li> </ol>"},{"location":"Medium/2%20Add%20Two%20Numbers/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(max(N, M))</li> <li>Space complexity: O(max(N, M))</li> </ul>"},{"location":"Medium/2%20Add%20Two%20Numbers/#keywords","title":"Keywords","text":"<ul> <li>Linked List</li> <li>Math</li> <li>Two Pointers</li> </ul>"},{"location":"Medium/2%20Add%20Two%20Numbers/#code","title":"Code","text":"<pre><code>/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\n\n type HL struct {\n     Head *ListNode\n     Tail *ListNode\n }\n func (hl *HL) Append(val int) {\n     newNode := &amp;ListNode{Val: val}\n     if hl.Head == nil{\n         hl.Head = newNode\n         hl.Tail = newNode\n     } else {\n         hl.Tail.Next =  newNode\n         hl.Tail = hl.Tail.Next\n     }\n }\nfunc addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {\n    hl := HL{}\n    carry_in := 0\n    for l1!=nil || l2!=nil || carry_in!=0 {\n        tmp := 0\n        if l1!=nil {\n            tmp += l1.Val\n            l1 = l1.Next\n        }\n        if l2!=nil {\n            tmp += l2.Val\n            l2 = l2.Next\n        }\n        tmp += carry_in\n        carry_in = tmp/10\n        hl.Append(tmp%10)\n    }\n    return hl.Head\n}\n</code></pre>"},{"location":"Medium/210%20Course%20Schedule%20II/","title":"210. Course Schedule II","text":""},{"location":"Medium/210%20Course%20Schedule%20II/#intuition","title":"Intuition","text":"<p>The problem is essentially about finding a valid topological order of courses given their prerequisites. We need to determine if it's possible to complete all courses and return the order in which they should be taken. This is a classic topological sorting problem where we need to find a linear ordering of vertices such that for every directed edge (u, v), vertex u comes before v in the ordering.</p>"},{"location":"Medium/210%20Course%20Schedule%20II/#approach","title":"Approach","text":"<ol> <li>Create a graph representation using an adjacency list and track the in-degree (number of prerequisites) for each course</li> <li>Initialize a queue with courses that have no prerequisites (in-degree = 0)</li> <li>Perform a BFS-like traversal:<ul> <li>Remove a course from the queue and add it to the result</li> <li>For each course that has this course as a prerequisite, decrease their in-degree</li> <li>If a course's in-degree becomes 0, add it to the queue</li> </ul> </li> <li>If the length of the result equals the total number of courses, return the result; otherwise, return an empty array indicating it's impossible to complete all courses</li> </ol>"},{"location":"Medium/210%20Course%20Schedule%20II/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(V + E)</li> <li>Space complexity: O(V + E)</li> </ul>"},{"location":"Medium/210%20Course%20Schedule%20II/#keywords","title":"Keywords","text":"<ul> <li>Topological Sort</li> <li>Graph</li> <li>BFS</li> </ul>"},{"location":"Medium/210%20Course%20Schedule%20II/#code","title":"Code","text":"<pre><code>func findOrder(numCourses int, prerequisites [][]int) []int {\n    type node struct {\n        ingress int\n        used bool\n        neighbor []int\n    }\n\n    ret, record := make([]int, 0), make([]node, numCourses)\n\n    for _, pre := range prerequisites {\n        a, b := pre[0], pre[1]\n        if !record[b].used {\n            record[b].neighbor = make([]int, 0)\n        }\n        record[a].used, record[b].used = true, true\n        record[a].ingress, record[b].neighbor = record[a].ingress + 1, append(record[b].neighbor, a)\n    }\n\n    current := make([]int, 0)\n    for i, n := range record {\n        if !n.used {\n            ret = append(ret, i)\n            continue\n        }\n        if n.ingress == 0 {\n            current = append(current, i)\n        }\n    }\n\n    for len(current) != 0 {\n        ret = append(ret, current...)\n        n := len(current)\n        for _, num := range current {\n            for _, nb := range record[num].neighbor {\n                record[nb].ingress -= 1\n                if record[nb].ingress == 0 {\n                    current = append(current, nb)\n                }\n            }\n        }\n        current = current[n:]\n    }\n\n    if len(ret) != numCourses {\n        return []int{}\n    }\n    return ret\n}\n</code></pre>"},{"location":"Medium/2294%20Partition%20Array%20Such%20That%20Maximum%20Difference%20Is%20K/","title":"2294. Partition Array Such That Maximum Difference Is K","text":""},{"location":"Medium/2294%20Partition%20Array%20Such%20That%20Maximum%20Difference%20Is%20K/#intuition","title":"Intuition","text":"<p>The main idea is to group the numbers in such a way that the difference between the smallest and largest number in each group does not exceed K. By sorting the array first, we can efficiently form such groups in a greedy manner.</p>"},{"location":"Medium/2294%20Partition%20Array%20Such%20That%20Maximum%20Difference%20Is%20K/#approach","title":"Approach","text":"<p>First, sort the input array.</p> <p>Then, iterate through the sorted array and start a new group whenever the current number exceeds the smallest number in the current group by more than K. Each time this happens, increment the group count and update the starting point of the new group.</p> <p>At the end, add one to the result to account for the last group.</p>"},{"location":"Medium/2294%20Partition%20Array%20Such%20That%20Maximum%20Difference%20Is%20K/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(n log n)</li> <li>Space complexity: O(1)</li> </ul>"},{"location":"Medium/2294%20Partition%20Array%20Such%20That%20Maximum%20Difference%20Is%20K/#keywords","title":"Keywords","text":"<ul> <li>Greedy</li> <li>Sorting</li> </ul>"},{"location":"Medium/2294%20Partition%20Array%20Such%20That%20Maximum%20Difference%20Is%20K/#code","title":"Code","text":"<pre><code>func partitionArray(nums []int, k int) int {\n    sort.Ints(nums)\n    ret, cur := 0, nums[0]\n\n    for _, n := range nums {\n        if n - cur &gt; k {\n            ret, cur = ret + 1, n\n        }\n    }\n    ret += 1\n\n    return ret\n}\n</code></pre>"},{"location":"Medium/236%20Lowest%20Common%20Ancestor%20of%20a%20Binary%20Tree/","title":"236. Lowest Common Ancestor of a Binary Tree","text":""},{"location":"Medium/236%20Lowest%20Common%20Ancestor%20of%20a%20Binary%20Tree/#intuition","title":"Intuition","text":"<p>We can use a post-order traversal approach where we first check the left and right subtrees, then process the current node.</p>"},{"location":"Medium/236%20Lowest%20Common%20Ancestor%20of%20a%20Binary%20Tree/#approach","title":"Approach","text":"<ol> <li>We use a recursive helper function <code>find</code> that takes the current node and the two target nodes p and q.</li> <li>The base cases are:<ul> <li>If the current node is nil, return nil</li> <li>If the current node is either p or q, return the current node</li> </ul> </li> <li>We recursively search in both left and right subtrees</li> <li>The logic for determining the LCA is:<ul> <li>If both left and right subtrees return nil, return nil (neither p nor q found)</li> <li>If only one subtree returns a non-nil value, return that value (one of p or q found)</li> <li>If both subtrees return non-nil values, the current node is the LCA</li> </ul> </li> </ol>"},{"location":"Medium/236%20Lowest%20Common%20Ancestor%20of%20a%20Binary%20Tree/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(n)</li> <li>Space complexity: O(h)</li> </ul>"},{"location":"Medium/236%20Lowest%20Common%20Ancestor%20of%20a%20Binary%20Tree/#keywords","title":"Keywords","text":"<ul> <li>Binary Tree</li> <li>Recursion</li> <li>DFS</li> <li>Post-order Traversal</li> <li>Lowest Common Ancestor</li> </ul>"},{"location":"Medium/236%20Lowest%20Common%20Ancestor%20of%20a%20Binary%20Tree/#code","title":"Code","text":"<pre><code>/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc find(node, p, q *TreeNode) *TreeNode {\n    if node == nil {\n        return nil\n    }\n    if node == p || node == q {\n        return node\n    }\n    left := find(node.Left, p, q)\n    right := find(node.Right, p, q)\n    if left == nil &amp;&amp; right == nil {\n        return nil\n    }\n    if left != nil &amp;&amp; right == nil {\n        return left\n    }\n    if left == nil &amp;&amp; right != nil {\n        return right\n    }\n    return node\n}\nfunc lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {\n    return find(root, p, q)\n}\n</code></pre>"},{"location":"Medium/24%20Swap%20Nodes%20in%20Pairs/","title":"24. Swap Nodes in Pairs","text":""},{"location":"Medium/24%20Swap%20Nodes%20in%20Pairs/#intuition","title":"Intuition","text":"<p>The key insight is to maintain proper connections while swapping nodes. We need to keep track of the node before each pair so we can properly reconnect the swapped pairs.</p>"},{"location":"Medium/24%20Swap%20Nodes%20in%20Pairs/#approach","title":"Approach","text":"<ol> <li>Create a dummy node (prev) that points to the head to handle the case when the head itself gets swapped</li> <li>Use a current pointer (cur) to track the node before each pair to be swapped</li> <li>For each pair (a, b):<ul> <li>Save references to both nodes</li> <li>Update a's next pointer to point to b's next</li> <li>Update b's next pointer to point to a</li> <li>Update cur's next pointer to point to b</li> <li>Move cur two nodes ahead for the next pair</li> </ul> </li> <li>Return prev.Next as the new head</li> </ol>"},{"location":"Medium/24%20Swap%20Nodes%20in%20Pairs/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(n)</li> <li>Space complexity: O(1)</li> </ul>"},{"location":"Medium/24%20Swap%20Nodes%20in%20Pairs/#keywords","title":"Keywords","text":"<ul> <li>Linked List</li> <li>Iterative</li> <li>In-place Modification</li> </ul>"},{"location":"Medium/24%20Swap%20Nodes%20in%20Pairs/#code","title":"Code","text":"<pre><code>/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc swapPairs(head *ListNode) *ListNode {\n    if head == nil || head.Next == nil {\n        return head\n    }\n    prev := &amp;ListNode{Val: 0, Next: head}\n    cur := prev\n    for cur.Next != nil {\n        a, b := cur.Next, cur.Next.Next\n        if b == nil {\n            break\n        }\n        a.Next = b.Next\n        cur.Next, b.Next = b, a\n        cur = cur.Next.Next\n    }\n    return prev.Next\n}\n</code></pre>"},{"location":"Medium/2966%20Divide%20Array%20Into%20Arrays%20With%20Max%20Difference/","title":"2966. Divide Array Into Arrays With Max Difference","text":""},{"location":"Medium/2966%20Divide%20Array%20Into%20Arrays%20With%20Max%20Difference/#intuition","title":"Intuition","text":"<p>The main idea is to group the sorted array into subarrays of size 3, ensuring that the maximum difference within each group does not exceed k. Sorting helps to minimize the difference within each group.</p>"},{"location":"Medium/2966%20Divide%20Array%20Into%20Arrays%20With%20Max%20Difference/#approach","title":"Approach","text":"<ol> <li>Sort the input array <code>nums</code> in ascending order.</li> <li>Iterate through the array in steps of 3, forming groups of three consecutive elements.</li> <li>For each group, check if the difference between the largest and smallest element is greater than <code>k</code>. If so, return an empty array as it's impossible to form such groups.</li> <li>If the group is valid, add it to the result.</li> <li>Return the list of valid groups.</li> </ol>"},{"location":"Medium/2966%20Divide%20Array%20Into%20Arrays%20With%20Max%20Difference/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(n log n)</li> <li>Space complexity: O(n)</li> </ul>"},{"location":"Medium/2966%20Divide%20Array%20Into%20Arrays%20With%20Max%20Difference/#keywords","title":"Keywords","text":"<ul> <li>Greedy</li> <li>Grouping</li> </ul>"},{"location":"Medium/2966%20Divide%20Array%20Into%20Arrays%20With%20Max%20Difference/#code","title":"Code","text":"<pre><code>func divideArray(nums []int, k int) [][]int {\n    ret := make([][]int, 0)\n    sort.Ints(nums)\n\n    for i := 0; i &lt; len(nums); i += 3 {\n        tmp := []int{nums[i]}\n        if (i + 1 &lt; len(nums) &amp;&amp; nums[i + 1] - nums[i] &gt; k) || (i + 2 &lt; len(nums) &amp;&amp; nums[i + 2] - nums[i] &gt; k) {\n            return [][]int{}\n        }\n        if i + 1 &lt; len(nums) {\n            tmp = append(tmp, nums[i + 1])\n        }\n        if i + 2 &lt; len(nums) {\n            tmp = append(tmp, nums[i + 2])\n        }\n        ret = append(ret, tmp)\n    }\n    return ret\n}\n</code></pre>"},{"location":"Medium/3%20Longest%20Substring%20Without%20Repeating%20Characters/","title":"3. Longest Substring Without Repeating Characters","text":""},{"location":"Medium/3%20Longest%20Substring%20Without%20Repeating%20Characters/#intuition","title":"Intuition","text":"<p>To find the longest substring without repeating characters, we can use the sliding window technique with two pointers (beginning and end) and a character frequency map. This allows us to efficiently track unique characters within our current window.</p>"},{"location":"Medium/3%20Longest%20Substring%20Without%20Repeating%20Characters/#approach","title":"Approach","text":"<ol> <li>Use a sliding window with two pointers: <code>beg</code> (start of window) and <code>end</code> (end of window)</li> <li>Maintain a frequency map (using an array of size 256 for ASCII characters) to track character occurrences</li> <li>For each character at the <code>end</code> pointer:<ul> <li>If the character hasn't been seen (frequency is 0), add it to our window and update max length</li> <li>If the character has been seen, shrink the window from the beginning until we remove the duplicate</li> </ul> </li> <li>Continue this process until we reach the end of the string</li> </ol>"},{"location":"Medium/3%20Longest%20Substring%20Without%20Repeating%20Characters/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(n)</li> <li>Space complexity: O(1)</li> </ul>"},{"location":"Medium/3%20Longest%20Substring%20Without%20Repeating%20Characters/#keywords","title":"Keywords","text":"<ul> <li>Sliding Window</li> <li>Two Pointers</li> </ul>"},{"location":"Medium/3%20Longest%20Substring%20Without%20Repeating%20Characters/#code","title":"Code","text":"<pre><code>func Max(a int, b int) int {\n    if a &gt; b {\n        return a\n    }\n    return b\n}\n\nfunc lengthOfLongestSubstring(s string) int {\n    mmap := [256]int{}\n    beg, end, max := 0, 0, 0\n    for end &lt; len(s) {\n        if mmap[s[end]] == 0 {\n            mmap[s[end]] = 1\n            end += 1\n            max = Max(max, end-beg)\n        } else {\n            mmap[s[beg]] = 0\n            beg += 1\n        }\n    }\n    return max\n}\n</code></pre>"},{"location":"Medium/316.%20Remove%20Duplicate%20Letters/","title":"316. Remove Duplicate Letters","text":""},{"location":"Medium/316.%20Remove%20Duplicate%20Letters/#intuition","title":"Intuition","text":"<p>The problem requires us to remove duplicate letters from a string while maintaining the lexicographically smallest possible result. We need to ensure that:</p> <ol> <li>Each character appears only once in the result</li> <li>The relative order of characters is preserved</li> <li>The result is lexicographically smallest among all possible results</li> </ol>"},{"location":"Medium/316.%20Remove%20Duplicate%20Letters/#approach","title":"Approach","text":"<ol> <li>First, we create a map <code>lastSeen</code> to record the last occurrence of each character in the string</li> <li>We use a stack (<code>st</code>) to build our result and a set (<code>seen</code>) to track characters we've already included</li> <li>For each character in the string:<ul> <li>If we haven't seen it before, we try to add it to our result</li> <li>Before adding, we check if we can remove characters from the stack that are:<ul> <li>Greater than the current character (to maintain lexicographical order)</li> <li>Will appear again later in the string (using lastSeen map)</li> </ul> </li> </ul> </li> <li>Finally, we convert the stack to a string and return it</li> </ol>"},{"location":"Medium/316.%20Remove%20Duplicate%20Letters/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(n)</li> <li>Space complexity: O(n)</li> </ul>"},{"location":"Medium/316.%20Remove%20Duplicate%20Letters/#keywords","title":"Keywords","text":"<ul> <li>Stack</li> <li>Greedy</li> <li>String</li> <li>Hash Map</li> <li>Lexicographical Order</li> </ul>"},{"location":"Medium/316.%20Remove%20Duplicate%20Letters/#code","title":"Code","text":"<pre><code>func removeDuplicateLetters(s string) string {\n    lastSeen := make(map[rune]int)\n    for i, c := range s {\n        lastSeen[c] = i\n    }\n\n    st, seen := make([]rune, 0), make(map[rune]bool)\n    for i, c := range s {\n        if !seen[c] {\n            for len(st) &gt; 0 &amp;&amp; c &lt; st[len(st) - 1] &amp;&amp; i &lt; lastSeen[st[len(st) - 1]] {\n                delete(seen, st[len(st) - 1])\n                st = st[: len(st) - 1]\n            }\n            seen[c], st = true, append(st, c)\n        }\n    }\n\n    return string(st)\n}\n</code></pre>"},{"location":"Medium/322%20Coin%20Change/","title":"322. Coin Change","text":""},{"location":"Medium/322%20Coin%20Change/#intuition","title":"Intuition","text":"<p>We can use dynamic programming to solve this problem by breaking it down into smaller subproblems. For each amount from 1 to the target amount, we can calculate the minimum number of coins needed by considering all possible coin denominations.</p>"},{"location":"Medium/322%20Coin%20Change/#approach","title":"Approach","text":"<ol> <li>First, handle edge cases:<ul> <li>If amount is 0, return 0</li> <li>If any coin equals the amount, return 1</li> <li>If all coins are larger than the amount, return -1</li> </ul> </li> <li>Initialize a DP array where dp[i] represents the minimum number of coins needed for amount i</li> <li>Set initial values:<ul> <li>dp[0] = 0 (0 coins needed for amount 0)</li> <li>All other values initialized to a large number (math.MaxInt - 1)</li> </ul> </li> <li>Sort the coins array for optimization</li> <li>For each amount from 1 to target amount:<ul> <li>For each coin denomination:<ul> <li>If the coin is less than or equal to the current amount</li> <li>Update dp[i] with the minimum of current value and (dp[i - coin] + 1)</li> </ul> </li> </ul> </li> <li>Return dp[amount] if it's not the initial large value, otherwise return -1</li> </ol>"},{"location":"Medium/322%20Coin%20Change/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(n * m)</li> <li>Space complexity: O(n)</li> </ul>"},{"location":"Medium/322%20Coin%20Change/#keywords","title":"Keywords","text":"<ul> <li>Dynamic Programming</li> <li>Bottom-up Approach</li> </ul>"},{"location":"Medium/322%20Coin%20Change/#code","title":"Code","text":"<pre><code>func coinChange(coins []int, amount int) int {\n    if amount == 0 {\n        return 0\n    }\n    smallFlag := false\n    for _, coin := range coins {\n        if coin == amount {\n            return 1\n        } else if coin &lt; amount {\n            smallFlag = true\n        }\n    }\n    if !smallFlag {\n        return -1\n    }\n\n    dp := make([]int, amount + 1)\n    for i := range dp {\n        dp[i] = math.MaxInt - 1\n    }\n    dp[0] = 0\n\n    sort.Ints(coins)\n\n    for i := 1; i &lt;= amount ; i += 1 {\n        for _, coin := range coins {\n            if coin &lt;= i {\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n            } else {\n                break\n            }\n        }\n    }\n    if dp[amount] == math.MaxInt - 1 {\n        return -1\n    }\n    return dp[amount]\n}\n</code></pre>"},{"location":"Medium/3355%20Zero%20Array%20Transformation%20I/","title":"3355. Zero Array Transformation I","text":""},{"location":"Medium/3355%20Zero%20Array%20Transformation%20I/#intuition","title":"Intuition","text":"<p>The problem requires us to check if we can transform an array into a zero array by applying a series of operations. Each operation decrements all elements within a given range [left, right]. The key insight is that we can track the cumulative effect of all operations at each position.</p>"},{"location":"Medium/3355%20Zero%20Array%20Transformation%20I/#approach","title":"Approach","text":"<ol> <li>Use two arrays <code>start</code> and <code>end</code> to track where operations begin and end</li> <li>For each query [left, right]:<ul> <li>Increment <code>start[left]</code> to mark operation starting point</li> <li>Increment <code>end[right]</code> to mark operation ending point</li> </ul> </li> <li>Iterate through the array:<ul> <li>Keep track of current active operations (<code>current</code>)</li> <li>Add new operations starting at current position</li> <li>Subtract operations ending at current position</li> <li>Check if remaining value after applying operations is positive</li> <li>If any value remains positive, return false</li> </ul> </li> </ol>"},{"location":"Medium/3355%20Zero%20Array%20Transformation%20I/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(n + q)</li> <li>Space complexity: O(n)</li> </ul>"},{"location":"Medium/3355%20Zero%20Array%20Transformation%20I/#keywords","title":"Keywords","text":"<ul> <li>Prefix Sum</li> <li>Range Operations</li> </ul>"},{"location":"Medium/3355%20Zero%20Array%20Transformation%20I/#code","title":"Code","text":"<pre><code>func isZeroArray(nums []int, queries [][]int) bool {\n    start, end := make([]int, len(nums)), make([]int, len(nums))\n    for _, query := range queries {\n        start[query[0]], end[query[1]] = start[query[0]] + 1, end[query[1]] + 1\n    }\n\n    current := 0\n    for i := range nums {\n        current += start[i]\n        nums[i] -= current\n        if nums[i] &gt; 0 {\n            return false\n        }\n        current -= end[i]\n    }\n\n    return true\n}\n</code></pre>"},{"location":"Medium/3362%20Zero%20Array%20Transformation%20III/","title":"3362 Zero Array Transformation III","text":""},{"location":"Medium/3362%20Zero%20Array%20Transformation%20III/#intuition","title":"Intuition","text":"<p>This problem requires us to transform an array to all zeros using a set of queries, where each query [i, j] allows us to decrease all elements from index i to j by 1. The key insight is to use a max heap to track the available ranges and greedily apply them to reduce numbers to zero.</p>"},{"location":"Medium/3362%20Zero%20Array%20Transformation%20III/#approach","title":"Approach","text":"<ol> <li>For each position i, we maintain a list of queries that start at i (start[i])</li> <li>We process the array from left to right:<ul> <li>For each position i, add all queries starting at i to the max heap</li> <li>Calculate how many decrements we need at current position (need)</li> <li>Use the available ranges from heap to satisfy the need:<ul> <li>Remove expired ranges (end &lt; current position)</li> <li>Apply ranges greedily, tracking when each range's effect expires</li> </ul> </li> </ul> </li> <li>If we can't satisfy the need at any position, return -1</li> <li>Return the number of unused queries</li> </ol>"},{"location":"Medium/3362%20Zero%20Array%20Transformation%20III/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(N * log Q)</li> <li>Space complexity: O(Q)</li> </ul>"},{"location":"Medium/3362%20Zero%20Array%20Transformation%20III/#keywords","title":"Keywords","text":"<ul> <li>Priority Queue (Heap)</li> <li>Greedy Algorithm</li> </ul>"},{"location":"Medium/3362%20Zero%20Array%20Transformation%20III/#code","title":"Code","text":"<pre><code>type Comparator func(child, parent interface{}) bool\ntype heap struct {\n    Storage []interface{}\n    CmpFunc Comparator\n}\n\nfunc NewHeap(cmpFunc Comparator) *heap {\n    return &amp;heap {\n        Storage: append(make([]interface{}, 0), -1),\n        CmpFunc: cmpFunc,\n    }\n}\n\nfunc (h *heap) Len() int {\n    return len(h.Storage) - 1\n}\n\nfunc (h *heap) IsEmpty() bool {\n    return h.Len() == 0\n}\n\nfunc (h *heap) cmp(child, parent interface{}) bool {\n    return h.CmpFunc(child, parent)\n}\n\nfunc (h *heap) swap(x, y int) {\n    h.Storage[x], h.Storage[y] = h.Storage[y], h.Storage[x]\n}\n\nfunc (h *heap) Top() (interface{}, error) {\n    if h.IsEmpty() {\n        return nil, errors.New(\"heap is empty\")\n    }\n    return h.Storage[1], nil\n}\n\nfunc (h *heap) Push(item interface{}) {\n    h.Storage = append(h.Storage, item)\n    now := h.Len()\n    for now / 2 &gt; 0 &amp;&amp; !h.cmp(h.Storage[now], h.Storage[now / 2]) {\n        h.swap(now, now / 2)\n        now /= 2\n    }\n}\n\nfunc (h *heap) Pop() (interface{}, error) {\n    top, err := h.Top()\n    if err != nil {\n        return nil, err\n    }\n    last := h.Len()\n    h.swap(1, last)\n    h.Storage = h.Storage[: last]\n    now := 1\n    for now &lt; last {\n        left, right := 0, 0\n        if now * 2 &lt; last &amp;&amp; !h.cmp(h.Storage[now * 2], h.Storage[now]) {\n            left = now * 2\n        }\n        if now * 2 + 1 &lt; last &amp;&amp; !h.cmp(h.Storage[now * 2 + 1], h.Storage[now]) {\n            right = now * 2 + 1\n        }\n\n        if left == 0 &amp;&amp; right == 0 {\n            break\n        } else if left != 0 &amp;&amp; right == 0 {\n            h.swap(now, left)\n            now = left\n        } else if left == 0 &amp;&amp; right != 0 {\n            h.swap(now, right)\n            now = right\n        } else {\n            if h.cmp(h.Storage[left], h.Storage[right]) {\n                h.swap(now, right)\n                now = right\n            } else {\n                h.swap(now, left)\n                now = left\n            }\n        }\n    }\n    return top, nil\n}\n\nfunc maxRemoval(nums []int, queries [][]int) int {\n    cmpFunc := func(child, parent interface{}) bool {\n        return child.(int) &lt; parent.(int)\n    }\n    hp, start, expireAt := NewHeap(cmpFunc), make([][]int, len(nums)), make([]int, len(nums))\n    for _, q := range queries {\n        start[q[0]] = append(start[q[0]], q[1])\n    }\n\n    chose, expire := 0, 0\n    for i, num := range nums {\n        for _, r := range start[i] {\n            hp.Push(r)\n        }\n\n        if i &gt; 0 {\n            expire += expireAt[i - 1]\n        }\n\n        need := num - (chose - expire)\n        for need &gt; 0 {\n            for !hp.IsEmpty() {\n                top, _ := hp.Top()\n                if top.(int) &lt; i {\n                    hp.Pop()\n                } else {\n                    break\n                }\n            }\n            if hp.IsEmpty() {\n                return -1\n            }\n\n            top, _ := hp.Pop()\n            expireAt[top.(int)] += 1\n            chose, need = chose + 1, need - 1\n        }\n    }\n\n    return len(queries) - chose\n}\n</code></pre>"},{"location":"Medium/3372%20Maximize%20the%20Number%20of%20Target%20Nodes%20After%20Connecting%20Trees%20I/","title":"3372. Maximize the Number of Target Nodes After Connecting Trees I","text":""},{"location":"Medium/3372%20Maximize%20the%20Number%20of%20Target%20Nodes%20After%20Connecting%20Trees%20I/#intuition","title":"Intuition","text":"<p>The problem involves connecting two trees and finding the maximum number of nodes that can be reached within k steps from each possible root node in tree1. The key insight is that we can:</p> <ol> <li>Calculate reachable nodes for each node in tree1 with k steps</li> <li>Find the maximum reachable nodes from any node in tree2 with k-1 steps</li> <li>Combine these results to get the final answer</li> </ol>"},{"location":"Medium/3372%20Maximize%20the%20Number%20of%20Target%20Nodes%20After%20Connecting%20Trees%20I/#approach","title":"Approach","text":"<ol> <li>First, we build adjacency lists for both trees using the given edges.</li> <li>Create a BFS function that:<ul> <li>Takes a tree, root node, and step limit k</li> <li>Returns the count of nodes reachable within k steps</li> <li>Uses a queue to track nodes to visit</li> <li>Uses visited array to avoid cycles</li> </ul> </li> <li>Main algorithm:<ul> <li>For each node i in tree1, calculate reachable nodes with k steps</li> <li>Find the maximum reachable nodes from any node in tree2 with k-1 steps</li> <li>For each node i in tree1, result[i] = tree1Count[i] + tree2MaxCount</li> </ul> </li> </ol>"},{"location":"Medium/3372%20Maximize%20the%20Number%20of%20Target%20Nodes%20After%20Connecting%20Trees%20I/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(N * (V + E))</li> <li>Space complexity: O(V)</li> </ul>"},{"location":"Medium/3372%20Maximize%20the%20Number%20of%20Target%20Nodes%20After%20Connecting%20Trees%20I/#keywords","title":"Keywords","text":"<ul> <li>Graph</li> <li>BFS</li> <li>Tree</li> </ul>"},{"location":"Medium/3372%20Maximize%20the%20Number%20of%20Target%20Nodes%20After%20Connecting%20Trees%20I/#code","title":"Code","text":"<pre><code>func maxTargetNodes(edges1 [][]int, edges2 [][]int, k int) []int {\n    buildTree := func(edges [][]int) map[int][]int {\n        tree := make(map[int][]int)\n        for _, e := range edges {\n            tree[e[0]], tree[e[1]] = append(tree[e[0]], e[1]), append(tree[e[1]], e[0])\n        }\n        return tree\n    }\n    tree1, tree2 := buildTree(edges1), buildTree(edges2)\n\n    bfs := func(tree map[int][]int, root, kk int) int {\n        count, q, visited := 0, []int{root}, make([]bool, len(tree))\n        visited[root] = true\n        for len(q) != 0 &amp;&amp; kk &gt;= 0 {\n            popN := len(q)\n            for _, n := range q {\n                for _, next := range tree[n] {\n                    if visited[next] {\n                        continue\n                    }\n                    q, visited[next] = append(q, next), true\n                }\n            }\n            q, kk, count = q[popN:], kk - 1, count + popN\n        }\n        return count\n    }\n\n    tree1Cnt, tree2Cnt := make([]int, len(tree1)), math.MinInt\n    for i := range tree1Cnt {\n        tree1Cnt[i] = bfs(tree1, i, k)\n    }\n    for i := range tree2 {\n        tree2Cnt = max(tree2Cnt, bfs(tree2, i, k - 1))\n    }\n\n    ret := make([]int, len(tree1))\n    for i := range ret {\n        ret[i] = tree1Cnt[i] + tree2Cnt\n    }\n\n    return ret\n}\n</code></pre>"},{"location":"Medium/3443%20Maximum%20Manhattan%20Distance%20After%20K%20Changes/","title":"3443. Maximum Manhattan Distance After K Changes","text":""},{"location":"Medium/3443%20Maximum%20Manhattan%20Distance%20After%20K%20Changes/#intuition","title":"Intuition","text":"<p>The problem asks for the maximum Manhattan distance that can be achieved after making at most k changes to a sequence of moves (N, S, W, E). The key idea is to track the net movement in each direction and, at each step, consider how changing up to k moves could further increase the distance.</p>"},{"location":"Medium/3443%20Maximum%20Manhattan%20Distance%20After%20K%20Changes/#approach","title":"Approach","text":"<p>We maintain an array to record the cumulative movement in each of the four directions.</p> <p>As we iterate through the string, we update the corresponding direction count. At every step, we calculate the current maximum and minimum values for the north-south and west-east axes.</p> <p>The Manhattan distance is computed as the sum of the differences between the maximum and minimum values for both axes. To maximize the distance, we can change up to k moves, so we add 2 * min(k, xm + ym) to the distance, where xm and ym are the minimum values for the two axes. We keep track of the maximum distance found during the iteration.</p>"},{"location":"Medium/3443%20Maximum%20Manhattan%20Distance%20After%20K%20Changes/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(n)</li> <li>Space complexity: O(1)</li> </ul>"},{"location":"Medium/3443%20Maximum%20Manhattan%20Distance%20After%20K%20Changes/#keywords","title":"Keywords","text":"<ul> <li>Manhattan distance</li> <li>Greedy</li> </ul>"},{"location":"Medium/3443%20Maximum%20Manhattan%20Distance%20After%20K%20Changes/#code","title":"Code","text":"<pre><code>func maxDistance(s string, k int) int {\n    dir, ret := make([]int, 4), math.MinInt\n    for _, d := range s {\n        switch d {\n        case 'N':\n            dir[0] += 1\n        case 'S':\n            dir[2] += 1\n        case 'W':\n            dir[1] += 1\n        case 'E':\n            dir[3] += 1\n        }\n        xM, xm := max(dir[0], dir[2]), min(dir[0], dir[2])\n        yM, ym := max(dir[1], dir[3]), min(dir[1], dir[3])\n        ret = max(ret, xM + yM - xm - ym + 2 * min(k, xm + ym))\n    }\n    return ret\n}\n</code></pre>"},{"location":"Medium/347%20Top%20K%20Frequent%20Elements/","title":"347. Top K Frequent Elements","text":""},{"location":"Medium/347%20Top%20K%20Frequent%20Elements/#intuition","title":"Intuition","text":"<p>The problem asks us to find the k most frequent elements in an array. The key insight is that we need to:</p> <ol> <li>Count the frequency of each element</li> <li>Find the k elements with the highest frequencies</li> </ol> <p>A heap (priority queue) is perfect for this task because it allows us to efficiently maintain the top k elements based on their frequencies.</p>"},{"location":"Medium/347%20Top%20K%20Frequent%20Elements/#approach","title":"Approach","text":"<ol> <li>Count Frequencies: Use a hash map to count the frequency of each element in the input array.</li> <li>Build Max Heap: Create a max heap where elements are ordered by their frequencies. We implement a custom heap data structure with:<ul> <li>A comparator function to define the heap property</li> <li>Standard heap operations: Push, Pop, Top</li> <li>Heap maintenance through up-heap and down-heap operations</li> </ul> </li> <li>Extract Top K: Push all unique elements with their frequencies into the heap, then pop k times to get the k most frequent elements.</li> </ol> <p>The custom heap implementation uses 1-indexed storage for easier parent-child calculations:</p> <ul> <li>Parent of node i: i/2</li> <li>Left child of node i: 2*i</li> <li>Right child of node i: 2*i+1</li> </ul>"},{"location":"Medium/347%20Top%20K%20Frequent%20Elements/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(n log n)</li> <li>Space complexity: O(n)</li> </ul>"},{"location":"Medium/347%20Top%20K%20Frequent%20Elements/#keywords","title":"Keywords","text":"<ul> <li>Hash Map</li> <li>Heap (Priority Queue)</li> <li>Frequency Counting</li> <li>Top K Problems</li> <li>Custom Data Structure</li> </ul>"},{"location":"Medium/347%20Top%20K%20Frequent%20Elements/#code","title":"Code","text":"<pre><code>type Comparator func(child, parent interface{}) bool\ntype heap struct {\n    Storage []interface{}\n    CmpFunc Comparator\n}\n\nfunc NewHeap(cmpFunc Comparator) *heap {\n    return &amp;heap {\n        Storage: append(make([]interface{}, 0), -1),\n        CmpFunc: cmpFunc,\n    }\n}\n\nfunc (h *heap) Len() int {\n    return len(h.Storage) - 1\n}\n\nfunc (h *heap) IsEmpty() bool {\n    return h.Len() == 0\n}\n\nfunc (h *heap) cmp(child, parent interface{}) bool {\n    return h.CmpFunc(child, parent)\n}\n\nfunc (h *heap) swap(x, y int) {\n    h.Storage[x], h.Storage[y] = h.Storage[y], h.Storage[x]\n}\n\nfunc (h *heap) Top() (interface{}, error) {\n    if h.IsEmpty() {\n        return nil, errors.New(\"Heap is empty.\")\n    }\n    return h.Storage[1], nil\n}\n\nfunc (h *heap) Push(item interface{}) {\n    h.Storage = append(h.Storage, item)\n    now := h.Len()\n    for now / 2 &gt; 0 &amp;&amp; !h.cmp(h.Storage[now], h.Storage[now / 2]) {\n        h.swap(now, now / 2)\n        now /= 2\n    }\n}\n\nfunc (h *heap) Pop() (interface{}, error) {\n    top, err := h.Top()\n    if err != nil {\n        return nil, err\n    }\n    last := h.Len()\n    h.swap(1, last)\n    h.Storage = h.Storage[: last]\n    now := 1\n    for now &lt; last {\n        left, right := 0, 0\n        if now * 2 &lt; last &amp;&amp; !h.cmp(h.Storage[now * 2], h.Storage[now]) {\n            left = now * 2\n        }\n        if now * 2 + 1 &lt; last &amp;&amp; !h.cmp(h.Storage[now * 2 + 1], h.Storage[now]) {\n            right = now * 2 + 1\n        }\n\n        if left == 0 &amp;&amp; right == 0 {\n            break\n        } else if left != 0 &amp;&amp; right == 0 {\n            h.swap(now, left)\n            now = left\n        } else if left == 0 &amp;&amp; right != 0 {\n            h.swap(now, right)\n            now = right\n        } else {\n            if h.cmp(h.Storage[left], h.Storage[right]) {\n                h.swap(now, right)\n                now = right\n            } else {\n                h.swap(now, left)\n                now = left\n            }\n        }\n    }\n    return top, nil\n}\n\nfunc topKFrequent(nums []int, k int) []int {\n    cnt := make(map[int]int)\n    for _, num := range nums {\n        cnt[num] += 1\n    }\n    type unit struct {\n        num, freq int\n    }\n    cmpFunc := func(child, parent interface{}) bool {\n        return child.(unit).freq &lt; parent.(unit).freq\n    }\n    hp, ret := NewHeap(cmpFunc), make([]int, 0)\n    for key, val := range cnt {\n        hp.Push(unit{key, val})\n    }\n    for k &gt; 0 {\n        top, _ := hp.Pop()\n        ret = append(ret, top.(unit).num)\n        k -= 1\n    }\n    return ret\n}\n</code></pre>"},{"location":"Medium/38%20Count%20and%20Say/","title":"38. Count and Say","text":""},{"location":"Medium/38%20Count%20and%20Say/#intuition","title":"Intuition","text":"<p>Brute force.</p>"},{"location":"Medium/38%20Count%20and%20Say/#approach","title":"Approach","text":"<ol> <li>Start with initial string \"1\"</li> <li>For each iteration (n-1 times):<ul> <li>Scan through the current string</li> <li>Count consecutive same characters</li> <li>Build the next string by combining the count and the character</li> </ul> </li> <li>Use a closure function to handle the counting and saying process</li> <li>Handle edge cases where character changes by resetting counter</li> </ol>"},{"location":"Medium/38%20Count%20and%20Say/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(N * M)</li> <li>Space complexity: O(M)</li> </ul>"},{"location":"Medium/38%20Count%20and%20Say/#keywords","title":"Keywords","text":"<ul> <li>String Manipulation</li> </ul>"},{"location":"Medium/38%20Count%20and%20Say/#code","title":"Code","text":"<pre><code>func countAndSay(n int) string {\n    init := \"1\"\n\n    cntAndSay := func() {\n        current, currentCnt, ret := '?', 0, \"\"\n        for _, char := range init {\n            if char != current {\n                ret += strconv.Itoa(currentCnt) + string(current)\n                current, currentCnt = char, 1\n            } else {\n                currentCnt += 1\n            }\n\n        }\n        ret += strconv.Itoa(currentCnt) + string(current)\n        init = string([]byte(ret[2:]))\n    }\n\n    for i := 1; i &lt; n; i += 1 {\n        cntAndSay()\n    }\n\n    return init\n}\n</code></pre>"},{"location":"Medium/386%20Lexicographical%20Numbers/","title":"386. Lexicographical Numbers","text":""},{"location":"Medium/386%20Lexicographical%20Numbers/#intuition","title":"Intuition","text":"<p>The problem requires us to find all numbers from 1 to n in lexicographical order. In lexicographical order, numbers are compared as strings, so \"1\" comes before \"2\", \"10\" comes before \"2\" because when comparing strings, we compare character by character from left to right. The key insight is that we can simulate this ordering by systematically exploring numbers digit by digit.</p>"},{"location":"Medium/386%20Lexicographical%20Numbers/#approach","title":"Approach","text":"<ol> <li>We start with the number 1 and use it as our current number (cnt).</li> <li>For each position in our result array:<ul> <li>Add the current number to the result</li> <li>If current number \u00d7 10 is still \u2264 n, we append 0 to explore the next level (multiply by 10)</li> <li>Otherwise:<ul> <li>If we've reached 9 in the last digit or exceeded n, we need to backtrack (divide by 10)</li> <li>Then increment by 1 to try the next number at the same level</li> </ul> </li> </ul> </li> <li>This process naturally generates numbers in lexicographical order because:<ul> <li>We always try to go deeper by appending 0 first</li> <li>When we can't go deeper, we increment the last digit</li> <li>When we can't increment anymore, we backtrack and try the next number</li> </ul> </li> </ol>"},{"location":"Medium/386%20Lexicographical%20Numbers/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(n)</li> <li>Space complexity: O(1)</li> </ul>"},{"location":"Medium/386%20Lexicographical%20Numbers/#keywords","title":"Keywords","text":"<ul> <li>Lexicographical Order</li> </ul>"},{"location":"Medium/386%20Lexicographical%20Numbers/#code","title":"Code","text":"<pre><code>func lexicalOrder(n int) []int {\n    ret, cnt := make([]int, n), 1\n\n    for i := 0; i &lt; n; i += 1 {\n        ret[i] = cnt\n\n        if cnt * 10 &lt;= n {\n            cnt *= 10\n        } else {\n            for cnt % 10 == 9 || cnt &gt;= n {\n                cnt /= 10\n            }\n            cnt += 1\n        }\n    }\n\n    return ret\n}\n</code></pre>"},{"location":"Medium/416%20Partition%20Equal%20Subset%20Sum/","title":"416. Partition Equal Subset Sum","text":""},{"location":"Medium/416%20Partition%20Equal%20Subset%20Sum/#intuition","title":"Intuition","text":"<p>The problem can be transformed into finding if we can select some numbers from the array that sum up to half of the total sum. This is essentially a 0/1 knapsack problem where we need to determine if we can fill a knapsack of capacity sum/2 using the given numbers.</p>"},{"location":"Medium/416%20Partition%20Equal%20Subset%20Sum/#approach","title":"Approach","text":"<ol> <li>First, calculate the total sum of the array</li> <li>If the sum is odd, return false as equal partition is impossible</li> <li>Divide the sum by 2 to get our target sum</li> <li>Use dynamic programming to solve:<ul> <li>Create a dp array where dp[j] represents if we can make sum j using the numbers</li> <li>For each number, we can either include it or not include it</li> <li>Use a temporary array to avoid affecting previous calculations</li> <li>If at any point we can make the target sum, return true</li> </ul> </li> <li>As an optimization, we also:<ul> <li>Sort the array first</li> <li>Use binary search to check if target sum exists directly in array</li> </ul> </li> </ol>"},{"location":"Medium/416%20Partition%20Equal%20Subset%20Sum/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(n * sum)</li> <li>Space complexity: O(sum)</li> </ul>"},{"location":"Medium/416%20Partition%20Equal%20Subset%20Sum/#keywords","title":"Keywords","text":"<ul> <li>Dynamic Programming</li> <li>0/1 Knapsack</li> <li>Binary Search</li> </ul>"},{"location":"Medium/416%20Partition%20Equal%20Subset%20Sum/#code","title":"Code","text":"<pre><code>func canPartition(nums []int) bool {\n    sum := 0\n    for _, num := range nums {\n        sum += num\n    }\n    if sum &amp; 1 == 1 {\n        return false\n    }\n    sum &gt;&gt;= 1\n    sort.Ints(nums)\n    _, flag := slices.BinarySearch(nums, sum)\n    if flag {\n        return true\n    }\n    dp := make([]bool, sum + 1)\n    dp[0] = true\n    for _, num := range nums {\n        tmp := make([]bool, sum + 1)\n        tmp[0] = true\n        for j := 1; j &lt;= sum ; j += 1 {\n            tmp[j] = dp[j]\n            if j &gt;= num {\n                tmp[j] = (tmp[j] || dp[j - num])\n            }\n        }\n\n        if tmp[sum] {\n            return true\n        }\n\n        copy(dp, tmp)\n    }\n    return dp[sum]\n}\n</code></pre>"},{"location":"Medium/435%20Non-overlapping%20Intervals/","title":"435. Non-overlapping Intervals","text":""},{"location":"Medium/435%20Non-overlapping%20Intervals/#intuition","title":"Intuition","text":"<p>To minimize the number of intervals that need to be removed to make the remaining intervals non-overlapping, we should:</p> <ol> <li>Sort the intervals by their end time</li> <li>Keep track of the current end time</li> <li>Remove intervals that overlap with the current end time</li> </ol>"},{"location":"Medium/435%20Non-overlapping%20Intervals/#approach","title":"Approach","text":"<ol> <li>Sort all intervals based on their end time in ascending order</li> <li>Initialize variables:<ul> <li><code>end</code>: tracks the end time of the last valid interval (initialized to -50001)</li> <li><code>ret</code>: counts the number of intervals that need to be removed</li> </ul> </li> <li>Iterate through the sorted intervals:<ul> <li>If current interval's start time is greater than or equal to previous end time:<ul> <li>Update end time to current interval's end time</li> </ul> </li> <li>Otherwise:<ul> <li>Increment the removal counter (ret)</li> </ul> </li> </ul> </li> <li>Return the total number of intervals that need to be removed</li> </ol>"},{"location":"Medium/435%20Non-overlapping%20Intervals/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(nlogn)</li> <li>Space complexity: O(1)</li> </ul>"},{"location":"Medium/435%20Non-overlapping%20Intervals/#keywords","title":"Keywords","text":"<ul> <li>Array</li> <li>Sorting</li> <li>Greedy</li> <li>Interval Scheduling</li> </ul>"},{"location":"Medium/435%20Non-overlapping%20Intervals/#code","title":"Code","text":"<pre><code>func eraseOverlapIntervals(intervals [][]int) int {\n    sort.Slice(intervals, func(i, j int) bool {\n        return intervals[i][1] &lt; intervals[j][1]\n    })\n    end, ret := -50001, 0\n    for _, interval := range intervals {\n        if end &lt;= interval[0] {\n            end = interval[1]\n        } else {\n            ret += 1\n        }\n    }\n    return ret\n}\n</code></pre>"},{"location":"Medium/45%20Jump%20Game%20II/","title":"45. Jump Game II","text":""},{"location":"Medium/45%20Jump%20Game%20II/#intuition","title":"Intuition","text":"<p>This problem is solved using a greedy algorithm. The core idea is to always choose positions that can reach the farthest distance at each jump. Instead of actually simulating the jumping process, we maintain two pointers tracking the current maximum reachable position and the farthest position we can reach in the next jump to calculate the minimum number of jumps.</p>"},{"location":"Medium/45%20Jump%20Game%20II/#approach","title":"Approach","text":"<ol> <li> <p>Use three variables:</p> <ul> <li>ret: records the minimum number of jumps</li> <li>current: the farthest position reachable in the current jump</li> <li>farthest: the farthest position reachable in the next jump from the current position</li> </ul> </li> <li> <p>While traversing the array:</p> <ul> <li>For each position i, calculate the farthest distance reachable from this position (i + nums[i])</li> <li>Update farthest to be the maximum reachable distance</li> <li>When we reach the current position, we need to make a jump:<ul> <li>Increment the jump count</li> <li>Update current to farthest</li> <li>If current can reach the end, break the loop</li> </ul> </li> </ul> </li> <li> <p>Finally, return the minimum number of jumps needed</p> </li> </ol>"},{"location":"Medium/45%20Jump%20Game%20II/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(n)</li> <li>Space complexity: O(1)</li> </ul>"},{"location":"Medium/45%20Jump%20Game%20II/#keywords","title":"Keywords","text":"<ul> <li>Greedy Algorithm</li> </ul>"},{"location":"Medium/45%20Jump%20Game%20II/#code","title":"Code","text":"<pre><code>func jump(nums []int) int {\n    if len(nums) == 1 {\n        return 0\n    }\n    ret, current, fartest := 0, 0, 0\n    for i, num := range nums {\n        fartest = max(fartest, i + num)\n        if i == current {\n            ret, current = ret + 1, fartest\n            if current &gt;= len(nums) - 1 {\n                break\n            }\n        }\n    }\n    return ret\n}\n</code></pre>"},{"location":"Medium/46%20Permutations/","title":"46. Permutations","text":""},{"location":"Medium/46%20Permutations/#intuition","title":"Intuition","text":"<p>The key insight is that we can build permutations recursively by selecting each number as the first element and then generating permutations for the remaining numbers.</p>"},{"location":"Medium/46%20Permutations/#approach","title":"Approach","text":"<ol> <li>Use a recursive backtracking approach</li> <li>For each recursive call:<ul> <li>If there are no numbers left to permute, add the current permutation to the result</li> <li>Otherwise, iterate through the remaining numbers</li> <li>For each number, create a new permutation by adding it to the current permutation</li> <li>Recursively call the function with the remaining numbers (excluding the current number)</li> </ul> </li> <li>The base case is when there are no numbers left to permute</li> </ol>"},{"location":"Medium/46%20Permutations/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(n * n!)</li> <li>Space complexity: O(n * n!)</li> </ul>"},{"location":"Medium/46%20Permutations/#keywords","title":"Keywords","text":"<ul> <li>Backtracking</li> <li>Recursion</li> <li>Permutation</li> </ul>"},{"location":"Medium/46%20Permutations/#code","title":"Code","text":"<pre><code>func recursion(cur, nums []int, ret *[][]int) {\n    if len(nums) == 0 {\n        *ret = append(*ret, cur)\n        return\n    }\n    for i, num := range nums {\n        cp := make([]int, len(nums))\n        copy(cp, nums)\n        recursion(append(cur, num), append(cp[:i], cp[i + 1:]...), ret)\n    }\n}\nfunc permute(nums []int) [][]int {\n    ret := make([][]int, 0)\n    recursion([]int{}, nums, &amp;ret)\n    return ret\n}\n</code></pre>"},{"location":"Medium/5%20Longest%20Palindromic%20Substring/","title":"5. Longest Palindromic Substring","text":""},{"location":"Medium/5%20Longest%20Palindromic%20Substring/#intuition","title":"Intuition","text":"<p>The key insight is to use dynamic programming to solve this problem. For each substring, we can determine if it's a palindrome based on:</p> <ol> <li>The characters at both ends must be equal</li> <li>The substring between these characters must also be a palindrome</li> </ol>"},{"location":"Medium/5%20Longest%20Palindromic%20Substring/#approach","title":"Approach","text":"<ol> <li>Create a 2D DP table where <code>dp[i][j]</code> represents whether the substring from index i to j is a palindrome</li> <li>Initialize single characters as palindromes (<code>dp[i][i] = true</code>)</li> <li>For each possible substring length:<ul> <li>Check if characters at both ends are equal</li> <li>If they are equal, check if the inner substring is also a palindrome</li> <li>Keep track of the longest palindrome found so far</li> </ul> </li> <li>Return the longest palindromic substring found</li> </ol>"},{"location":"Medium/5%20Longest%20Palindromic%20Substring/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(n\u00b2)</li> <li>Space complexity: O(n\u00b2)</li> </ul>"},{"location":"Medium/5%20Longest%20Palindromic%20Substring/#keywords","title":"Keywords","text":"<ul> <li>Dynamic Programming</li> <li>String</li> <li>Palindrome</li> <li>Two-dimensional DP</li> </ul>"},{"location":"Medium/5%20Longest%20Palindromic%20Substring/#code","title":"Code","text":"<pre><code>func longestPalindrome(s string) string {\n    dp := make([][]bool, len(s))\n    for i := range dp {\n        dp[i] = make([]bool, len(s))\n        dp[i][i] = true\n    }\n    maxLength, l, r := 1, 0, 0\n    for i := len(s) - 1; i &gt;= 0; i -= 1 {\n        for j := i; j &lt; len(s); j += 1 {\n            if s[i] == s[j] {\n                if i + 1 &lt;= j - 1 {\n                    if dp[i + 1][j - 1] {\n                        dp[i][j] = true\n                    }\n                } else {\n                    dp[i][j] = true\n                }\n            }\n\n            if dp[i][j] &amp;&amp; j - i + 1 &gt; maxLength {\n                maxLength, l, r = j - i + 1, i, j\n            }\n        }\n    }\n    return string(s[l: r + 1])\n}\n</code></pre>"},{"location":"Medium/50%20Pow%28x%2C%20n%29/","title":"50. Pow(x, n)","text":""},{"location":"Medium/50%20Pow%28x%2C%20n%29/#intuition","title":"Intuition","text":"<p>A naive approach would be to multiply x by itself n times, but this would be inefficient for large values of n. Instead, we can use the property that x ^ n = [x ^ (n/2)] ^ 2 when n is even, and x ^ n = x * [x ^ (n/2)] ^ 2 when n is odd.</p>"},{"location":"Medium/50%20Pow%28x%2C%20n%29/#approach","title":"Approach","text":"<ol> <li>Handle the base case: If n is 0, return 1.</li> <li>Create a memoization map to store computed powers and avoid redundant calculations.</li> <li>Implement two recursive functions:<ul> <li><code>recurPositive</code> for positive exponents</li> <li><code>recurNegative</code> for negative exponents</li> </ul> </li> <li>For both functions:<ul> <li>Check if the result for the current exponent is already in the map</li> <li>For even exponents, calculate the result for n/2 and square it</li> <li>For odd exponents, do the same but multiply by x (or divide by x for negative exponents)</li> </ul> </li> <li>Handle negative exponents by using the relation x^(-n) = 1/(x ^ n)</li> </ol>"},{"location":"Medium/50%20Pow%28x%2C%20n%29/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(log n)</li> <li>Space complexity: O(log n)</li> </ul>"},{"location":"Medium/50%20Pow%28x%2C%20n%29/#keywords","title":"Keywords","text":"<ul> <li>Binary Exponentiation</li> <li>Divide and Conquer</li> <li>Recursion</li> <li>Fast Power Algorithm</li> </ul>"},{"location":"Medium/50%20Pow%28x%2C%20n%29/#code","title":"Code","text":"<pre><code>func myPow(x float64, n int) float64 {\n    if n == 0 {\n        return 1\n    }\n    record := make(map[int]float64)\n\n    var recurPositive func(curN int) float64\n    var recurNegative func(curN int) float64\n    recurPositive = func(curN int) float64 {\n        if v, found := record[curN]; found {\n            return v\n        }\n\n        flag := false\n        if curN &amp; 1 == 1 {\n            flag = true\n            curN -= 1\n        }\n        tmp := recurPositive(curN / 2)\n        record[curN] = tmp * tmp\n        if flag {\n            record[curN + 1] = record[curN] * x\n            return record[curN + 1]\n        }\n        return record[curN]\n    }\n    recurNegative = func(curN int) float64 {\n        if v, found := record[curN]; found {\n            return v\n        }\n\n        flag := false\n        if curN &amp; 1 == 1 {\n            flag = true\n            curN += 1\n        }\n        tmp := recurNegative(curN / 2)\n        record[curN] = tmp * tmp\n        if flag {\n            record[curN - 1] = record[curN] / x\n            return record[curN - 1]\n        }\n        return record[curN]\n    }\n    if n &lt; 0 {\n        record[-1] = 1/x\n        return recurNegative(n)\n    }\n    record[1] = x\n    return recurPositive(n)\n}\n</code></pre>"},{"location":"Medium/592%20Fraction%20Addition%20and%20Subtraction/","title":"592 Fraction Addition and Subtraction","text":""},{"location":"Medium/592%20Fraction%20Addition%20and%20Subtraction/#intuition","title":"Intuition","text":"<p>Just put the fractions into a map and only extract the non-zero value to do \"Add\", and divide the numerator and the denominator with their GCD.</p>"},{"location":"Medium/592%20Fraction%20Addition%20and%20Subtraction/#approach","title":"Approach","text":"<p>Before we preform the math operation, we need to do the string manipulation on the input. Using a map to store each fraction with key and value are denominator and numerator, respectively. In this step we can first sum the fractions which have same demonitor.</p> <p>Then, we will extract the non-zero fraction from the map, i.e., the value(numerator) is not zero and store the key(denominator) to a list.</p> <p>Go check if there is no any number in the list and return \"0/1\".</p> <p>Go check if there is only one number in the list and return this fraction with diving their GCD, since there does not need any \"Add\" operation.</p> <p>Otherwise, walk through the list and extract each fraction to perform addition with common denominators on each fraction in the list. After each addition, do a GCD division on this new \"fraction\". The top and down variable is refered as the fianl retuen fraction's numerator and denominator.</p>"},{"location":"Medium/592%20Fraction%20Addition%20and%20Subtraction/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(N)</li> <li>Space complexity: O(N)</li> </ul>"},{"location":"Medium/592%20Fraction%20Addition%20and%20Subtraction/#keywords","title":"Keywords","text":"<ul> <li>String</li> <li>GCD</li> <li>Math</li> </ul>"},{"location":"Medium/592%20Fraction%20Addition%20and%20Subtraction/#code","title":"Code","text":"<pre><code>func fractionAddition(expression string) string {\n    fraction, idx := make(map[int]int), 0\n    for idx &lt; len(expression) {\n        top, down := \"\", \"\"\n        for expression[idx] != '/' {\n            top += string(expression[idx])\n            idx += 1\n        }\n        idx += 1\n        for idx &lt; len(expression) &amp;&amp; expression[idx] != '+' &amp;&amp; expression[idx] != '-' {\n            down += string(expression[idx])\n            idx += 1\n        }\n        t, _ := strconv.Atoi(top)\n        d, _ := strconv.Atoi(down)\n        fraction[d] += t\n    }\n    downs := make([]int, 0)\n    for k, v := range fraction {\n        if v == 0 {\n            continue\n        }\n        downs = append(downs, k)\n    }\n    if len(downs) == 0 {\n        return \"0/1\"\n    }\n    gcd := func(a, b int) int {\n        for b &gt; 0 {\n            t := a % b\n            a, b = b, t\n        }\n        return a\n    }\n    if len(downs) == 1 {\n        g := gcd(int(math.Abs(float64(fraction[downs[0]]))), downs[0])\n        return fmt.Sprintf(\"%v/%v\", fraction[downs[0]] / g, downs[0] / g)\n    }\n    top, down := 0, 1\n    for _, val := range downs {\n        top, down = (top * val + fraction[val] * down), down * val\n        g := gcd(int(math.Abs(float64(top))), down)\n        top, down = top / g, down / g\n    }\n    return fmt.Sprintf(\"%v/%v\", top, down)\n}\n</code></pre>"},{"location":"Medium/6%20Zigzag%20Conversion/","title":"6. Zigzag Conversion","text":""},{"location":"Medium/6%20Zigzag%20Conversion/#intuition","title":"Intuition","text":"<p>The key insight is to understand that the zigzag pattern follows a predictable sequence. We can simulate this pattern by using a flag to control the direction (up or down) and maintaining separate arrays for each row. The characters are distributed row by row, changing direction when we hit the top or bottom row.</p>"},{"location":"Medium/6%20Zigzag%20Conversion/#approach","title":"Approach","text":"<ol> <li>Create a 2D array where each inner array represents a row in the zigzag pattern</li> <li>Use a flag to track the direction of movement (true for moving down, false for moving up)</li> <li>Iterate through each character in the input string:<ul> <li>Add the character to the current row</li> <li>Update the row index based on the direction</li> <li>Change direction when reaching the top or bottom row</li> </ul> </li> <li>Finally, concatenate all rows to form the result string</li> </ol>"},{"location":"Medium/6%20Zigzag%20Conversion/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(n)</li> <li>Space complexity: O(n)</li> </ul>"},{"location":"Medium/6%20Zigzag%20Conversion/#keywords","title":"Keywords","text":"<ul> <li>String Manipulation</li> <li>Pattern Recognition</li> <li>Two-dimensional Array</li> </ul>"},{"location":"Medium/6%20Zigzag%20Conversion/#code","title":"Code","text":"<pre><code>func convert(s string, numRows int) string {\n    arr := make([][]rune, numRows)\n    for i := 0; i &lt; numRows; i++ {\n        arr[i] = make([]rune, 0)\n    }\n    flag := true\n    idx := 0\n    for _, char := range s {\n        arr[idx] = append(arr[idx], char)\n        if flag {\n            if idx == numRows - 1 {\n                flag = false\n                idx -= 1\n                if idx == -1 {\n                    idx = 0\n                }\n            } else {\n                idx += 1\n            }\n        } else {\n            if idx == 0 {\n                flag = true\n                idx += 1\n                if idx == numRows {\n                    idx = numRows - 1\n                }\n            } else {\n                idx -= 1\n            }\n        }\n    }\n    ret := make([]rune, len(s))\n    idx = 0\n    for _, substring := range arr {\n        copy(ret[idx: idx + len(substring)], substring)\n        idx += len(substring)\n    }\n    return string(ret)\n}\n</code></pre>"},{"location":"Medium/7%20Reverse%20Integer/","title":"7. Reverse Integer","text":""},{"location":"Medium/7%20Reverse%20Integer/#intuition","title":"Intuition","text":"<p>The key idea is to extract each digit from the input number from right to left and build the reversed number. We need to be careful about integer overflow since the problem requires handling 32-bit integer constraints.</p>"},{"location":"Medium/7%20Reverse%20Integer/#approach","title":"Approach","text":"<ol> <li>Initialize a variable <code>ans</code> to store the reversed number</li> <li>While the input number <code>x</code> is not zero:<ul> <li>Get the last digit using modulo operation (<code>x % 10</code>)</li> <li>Remove the last digit from x by integer division (<code>x /= 10</code>)</li> <li>Build the reversed number by multiplying current ans by 10 and adding the new digit</li> <li>Check for 32-bit integer overflow</li> </ul> </li> <li>Return the reversed number if no overflow occurred</li> </ol>"},{"location":"Medium/7%20Reverse%20Integer/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(log(x))</li> <li>Space complexity: O(1)</li> </ul>"},{"location":"Medium/7%20Reverse%20Integer/#keywords","title":"Keywords","text":"<ul> <li>Math</li> <li>Integer Overflow</li> <li>Modulo Operation</li> <li>32-bit Integer Constraints</li> </ul>"},{"location":"Medium/7%20Reverse%20Integer/#code","title":"Code","text":"<pre><code>func reverse(x int) int {\n    ans := 0\n    for x != 0 {\n        num := x%10\n        x /= 10\n        ans = ans*10 + num\n\n        if ans &lt; -1*int(^uint32(0)&gt;&gt;1) || ans &gt; int(^uint32(0)&gt;&gt;1) {\n            return 0\n        }\n    }\n    return ans\n}\n</code></pre>"},{"location":"Medium/73%20Set%20Matrix%20Zeroes/","title":"73. Set Matrix Zeroes","text":""},{"location":"Medium/73%20Set%20Matrix%20Zeroes/#intuition","title":"Intuition","text":"<p>The problem requires us to set entire rows and columns to zero when we encounter a zero element in the matrix. A straightforward approach would be to first identify all rows and columns that need to be zeroed out, and then apply these changes to the matrix.</p>"},{"location":"Medium/73%20Set%20Matrix%20Zeroes/#approach","title":"Approach","text":"<ol> <li>Use two hash maps to track which rows and columns need to be zeroed out</li> <li>First pass: iterate through the matrix to mark rows and columns containing zeros</li> <li>Second pass:<ul> <li>For marked rows, set the entire row to zero</li> <li>For other rows, only set the marked columns to zero</li> </ul> </li> <li>Use a pre-created zero array for efficient row zeroing</li> </ol>"},{"location":"Medium/73%20Set%20Matrix%20Zeroes/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(m*n)</li> <li>Space complexity: O(m+n)</li> </ul>"},{"location":"Medium/73%20Set%20Matrix%20Zeroes/#keywords","title":"Keywords","text":"<ul> <li>Matrix</li> <li>Hash Map</li> </ul>"},{"location":"Medium/73%20Set%20Matrix%20Zeroes/#code","title":"Code","text":"<pre><code>func setZeroes(matrix [][]int)  {\n    rmp, cmp := make(map[int]bool), make(map[int]bool)\n    for i, line := range matrix {\n        for j, item := range line {\n            if item == 0 {\n                rmp[i], cmp[j] = true, true\n            }\n        }\n    }\n    zero := make([]int, len(matrix[0]))\n    for i, line := range matrix {\n        if rmp[i] {\n            copy(matrix[i], zero)\n            continue\n        }\n        for j := range line {\n            if cmp[j] {\n                matrix[i][j] = 0\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"Medium/752%20Open%20the%20Lock/","title":"752 Open the Lock","text":""},{"location":"Medium/752%20Open%20the%20Lock/#intuition","title":"Intuition","text":"<p>The problem can be modeled as a graph traversal problem where each node represents a lock combination (4-digit number) and edges represent valid moves (turning one wheel up or down). We need to find the shortest path from \"0000\" to the target combination while avoiding deadends. This naturally leads to using BFS (Breadth-First Search) as it guarantees finding the shortest path in an unweighted graph.</p>"},{"location":"Medium/752%20Open%20the%20Lock/#approach","title":"Approach","text":"<ol> <li>Start with the initial combination \"0000\"</li> <li>Use BFS to explore all possible combinations:<ul> <li>For each digit in the current combination, try turning it up and down</li> <li>Skip combinations that are in the deadends list</li> <li>Keep track of visited combinations to avoid cycles</li> <li>Return the number of steps when the target is found</li> </ul> </li> <li>If the queue becomes empty without finding the target, return -1</li> </ol>"},{"location":"Medium/752%20Open%20the%20Lock/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(N), where N is the number of possible combinations (10^4 = 10000)</li> <li>Space complexity: O(N)</li> </ul>"},{"location":"Medium/752%20Open%20the%20Lock/#keywords","title":"Keywords","text":"<ul> <li>BFS</li> <li>Graph Traversal</li> </ul>"},{"location":"Medium/752%20Open%20the%20Lock/#code","title":"Code","text":"<pre><code>func openLock(deadends []string, target string) int {\n    if \"0000\" == target {\n        return 0\n    }\n    dds, record, ret := make(map[string]bool, len(deadends)), make(map[string]bool), 0\n    for _, dd := range deadends {\n        dds[dd] = true\n    }\n    if dds[\"0000\"] {\n        return -1\n    }\n    record[target] = true\n\n    newCurProcess := func(i int, destDigit byte, cur string, tmp *[]string) bool {\n        curByte := []byte(cur)\n        curByte[i] = destDigit\n        cur = string(curByte)\n        if dds[cur] {\n            return false\n        }\n        if cur == target {\n            return true\n        }\n        if _, found := record[cur]; !found {\n            *tmp, record[cur] = append(*tmp, cur), true\n        }\n        return false\n    }\n\n    getNext := func(cur string, tmp *[]string) bool {\n        for i := 0; i &lt; 4; i += 1 {\n            switch cur[i] {\n            case '0':\n                if newCurProcess(i, '1', cur, tmp) {\n                    return true\n                }\n                if newCurProcess(i, '9', cur, tmp) {\n                    return true\n                }\n            case '9':\n                if newCurProcess(i, '0', cur, tmp) {\n                    return true\n                }\n                if newCurProcess(i, '8', cur, tmp) {\n                    return true\n                }\n            default:\n                if newCurProcess(i, cur[i] + 1, cur, tmp) {\n                    return true\n                }\n                if newCurProcess(i, cur[i] - 1, cur, tmp) {\n                    return true\n                }\n            }\n        }\n        return false\n    }\n\n    queue := []string{\"0000\"}\n    for len(queue) != 0 {\n        ret += 1\n        tmp := make([]string, 0)\n        for _, cur := range queue {\n            if getNext(cur, &amp;tmp) {\n                return ret\n            }\n        }\n        queue = tmp\n    }\n\n    return -1\n}\n</code></pre>"},{"location":"Medium/8%20String%20to%20Integer%20%28atoi%29/","title":"8. String to Integer (atoi)","text":""},{"location":"Medium/8%20String%20to%20Integer%20%28atoi%29/#intuition","title":"Intuition","text":"<p>The problem requires us to convert a string to an integer, similar to the C/C++ atoi function. We need to handle various edge cases including:</p> <ul> <li>Leading whitespaces</li> <li>Optional plus/minus sign</li> <li>Numerical digits</li> <li>Overflow conditions</li> <li>Invalid characters</li> </ul>"},{"location":"Medium/8%20String%20to%20Integer%20%28atoi%29/#approach","title":"Approach","text":"<ol> <li>Skip all leading whitespaces</li> <li>Check for optional plus or minus sign</li> <li>Process numerical digits:<ul> <li>Convert each digit to integer</li> <li>Build the number by multiplying current result by 10 and adding new digit</li> <li>Handle overflow by checking against INT_MAX/INT_MIN</li> </ul> </li> <li>Return the final result with appropriate sign</li> </ol>"},{"location":"Medium/8%20String%20to%20Integer%20%28atoi%29/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(n)</li> <li>Space complexity: O(1)</li> </ul>"},{"location":"Medium/8%20String%20to%20Integer%20%28atoi%29/#keywords","title":"Keywords","text":"<ul> <li>String Parsing</li> <li>Integer Overflow</li> <li>Edge Cases</li> </ul>"},{"location":"Medium/8%20String%20to%20Integer%20%28atoi%29/#code","title":"Code","text":"<pre><code>func myAtoi(s string) int {\n    ret, sign, i := 0, true, 0\n    for ; i &lt; len(s) &amp;&amp; s[i] == ' '; i += 1 {}\n    if i &lt; len(s) {\n        if s[i] == '-' {\n            sign, i = false, i + 1\n        } else if s[i] == '+' {\n            i += 1\n        }\n    }\n    for ; i &lt; len(s); i += 1 {\n        c := s[i]\n        switch c {\n        case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n            ret = ret * 10 + int(c - '0')\n            if ret &gt; int(^uint32(0) &gt;&gt; 1) {\n                if !sign {\n                    return -1 * int(^uint32(0) &gt;&gt; 1) - 1\n                }\n                return int(^uint32(0) &gt;&gt; 1)\n            }\n        default:\n            goto RETURN\n        }\n    }\nRETURN:\n    if !sign {\n        ret = -ret\n    }\n    return int(ret)\n}\n</code></pre>"},{"location":"Medium/840%20Magic%20Squares%20In%20Grid/","title":"840 Magic Squares In Grid","text":""},{"location":"Medium/840%20Magic%20Squares%20In%20Grid/#intuition","title":"Intuition","text":"<p>As we konw that the magicSquares is limited in 3x3, we can prepare these all magicSquares in advanced (only 8 types). Then we can just slide the 3x3 window through the input grid and get the the answer.</p>"},{"location":"Medium/840%20Magic%20Squares%20In%20Grid/#approach","title":"Approach","text":"<p>First, prepare the magicSquares. Second, check the size of the grid if it is larger than 3x3; otherwise, it does not need to continue. Last, slide the 3x3 window through the whole inpput grid.</p>"},{"location":"Medium/840%20Magic%20Squares%20In%20Grid/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(n^2)</li> <li>Space complexity: O(n^2)</li> </ul>"},{"location":"Medium/840%20Magic%20Squares%20In%20Grid/#keywords","title":"Keywords","text":"<ul> <li>Sliding Window</li> <li>Matrix</li> </ul>"},{"location":"Medium/840%20Magic%20Squares%20In%20Grid/#code","title":"Code","text":"<pre><code>func numMagicSquaresInside(grid [][]int) int {\n    magicSquares := [][][]int{\n        {\n            {8, 1, 6},\n            {3, 5, 7},\n            {4, 9, 2},\n        },\n        {\n            {4, 3, 8},\n            {9, 5, 1},\n            {2, 7, 6},\n        },\n        {\n            {2, 9, 4},\n            {7, 5, 3},\n            {6, 1, 8},\n        },\n        {\n            {6, 7, 2},\n            {1, 5, 9},\n            {8, 3, 4},\n        },\n        {\n            {4, 9, 2},\n            {3, 5, 7},\n            {8, 1, 6},\n        },\n        {\n            {2, 7, 6},\n            {9, 5, 1},\n            {4, 3, 8},\n        },\n        {\n            {6, 1, 8},\n            {7, 5, 3},\n            {2, 9, 4},\n        },\n        {\n            {8, 3, 4},\n            {1, 5, 9},\n            {6, 7, 2},\n        },\n    }\n    ret, r, c := 0, len(grid), len(grid[0])\n    if r &lt; 3 || c &lt; 3 {\n        return 0\n    }\n    var check func(x, y int) int\n    var checkRow func(a, b []int) bool\n    checkRow = func(a, b []int) bool {\n        for i := range a {\n            if a[i] != b[i] {\n                return false\n            }\n        }\n        return true\n    }\n    check = func(x, y int) int {\n        matrix := make([][]int, 3)\n        for i := range matrix {\n            matrix[i] = grid[x + i][y: y + 3]\n        }\n        for _, m := range magicSquares {\n            if checkRow(m[0], matrix[0]) &amp;&amp; checkRow(m[1], matrix[1]) &amp;&amp; checkRow(m[2], matrix[2]) {\n                return 1\n            }\n        }\n        return 0\n    }\n    for i := 0; i &lt; r - 2; i += 1 {\n        for j := 0; j &lt; c - 2; j += 1 {\n            ret += check(i, j)\n        }\n    }\n    return ret\n}\n</code></pre>"},{"location":"Medium/855%20Exam%20Room/","title":"855. Exam Room","text":""},{"location":"Medium/855%20Exam%20Room/#intuition","title":"Intuition","text":"<p>When a new student enters, we need to find the seat that maximizes the minimum distance to any other student. When a student leaves, we need to efficiently remove them from the seating arrangement.</p>"},{"location":"Medium/855%20Exam%20Room/#approach","title":"Approach","text":"<ol> <li>Use a sorted array to maintain the current seating arrangement</li> <li>For the <code>Seat()</code> operation:<ul> <li>If the room is empty, place the first student at seat 0</li> <li>Otherwise, find the maximum gap between existing students</li> <li>Consider three cases:<ol> <li>Gap at the beginning (seat 0)</li> <li>Gaps between existing students</li> <li>Gap at the end (last seat)</li> </ol> </li> <li>Insert the new student at the position that creates the maximum minimum distance</li> </ul> </li> <li>For the <code>Leave()</code> operation:<ul> <li>Use binary search to find the student's position</li> <li>Remove them from the array while maintaining the sorted order</li> </ul> </li> </ol>"},{"location":"Medium/855%20Exam%20Room/#complexity","title":"Complexity","text":"<ul> <li>Time complexity:<ul> <li>Seat(): O(n)</li> <li>Leave(): O(log n)</li> </ul> </li> <li>Space complexity: O(n)</li> </ul>"},{"location":"Medium/855%20Exam%20Room/#keywords","title":"Keywords","text":"<ul> <li>Binary Search</li> </ul>"},{"location":"Medium/855%20Exam%20Room/#code","title":"Code","text":"<pre><code>type ExamRoom struct {\n    seats int\n    students []int\n}\n\n\nfunc Constructor(n int) ExamRoom {\n    return ExamRoom{\n        seats: n,\n        students: make([]int, 0),\n    }\n}\n\n\nfunc (e *ExamRoom) Seat() int {\n    if len(e.students) == 0 {\n        e.students = append(e.students, 0)\n        return 0\n    }\n\n    seat, distance, idx := 0, e.students[0], 0\n\n    for i := 0; i &lt; len(e.students) - 1; i += 1 {\n        curDistance := (e.students[i + 1] - e.students[i]) / 2\n        if curDistance &gt; distance {\n            distance, seat, idx = curDistance, e.students[i] + curDistance, i + 1\n        }\n    }\n\n    if e.seats - 1 - e.students[len(e.students) - 1] &gt; distance {\n        distance = e.seats - 1 - e.students[len(e.students) - 1]\n        seat, idx = e.seats - 1, len(e.students)\n    }\n\n    e.students = append(e.students, 0)\n    copy(e.students[idx + 1:], e.students[idx:])\n    e.students[idx] = seat\n    return seat\n}\n\n\nfunc (e *ExamRoom) Leave(p int)  {\n    l, r := 0, len(e.students) - 1\n    for l &lt;= r {\n        m := (l + r) &gt;&gt; 1\n        if e.students[m] == p {\n            e.students = append(e.students[:m], e.students[m + 1:]...)\n            return\n        }\n\n        if e.students[m] &lt; p {\n            l = m + 1\n        } else {\n            r = m - 1\n        }\n    }\n}\n\n\n/**\n * Your ExamRoom object will be instantiated and called as such:\n * obj := Constructor(n);\n * param_1 := obj.Seat();\n * obj.Leave(p);\n */\n</code></pre>"},{"location":"Medium/875%20Koko%20Eating%20Bananas/","title":"875. Koko Eating Bananas","text":""},{"location":"Medium/875%20Koko%20Eating%20Bananas/#intuition","title":"Intuition","text":"<p>We can use binary search to find the optimal speed since:</p> <ol> <li>If Koko can finish bananas at speed k, she can definitely finish them at any speed &gt; k</li> <li>If Koko cannot finish bananas at speed k, she definitely cannot finish them at any speed &lt; k</li> </ol>"},{"location":"Medium/875%20Koko%20Eating%20Bananas/#approach","title":"Approach","text":"<ol> <li>Use binary search to find the minimum eating speed</li> <li>The search range is from 1 to the maximum pile size</li> <li>For each speed k:<ul> <li>Check if Koko can finish all piles within h hours</li> <li>If pile size \u2264 k, it takes 1 hour</li> <li>If pile size &gt; k, it takes (pile size / k) hours, rounded up</li> </ul> </li> <li>Return the minimum speed that allows Koko to finish all bananas</li> </ol>"},{"location":"Medium/875%20Koko%20Eating%20Bananas/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(n * log M)</li> <li>Space complexity: O(1)</li> </ul>"},{"location":"Medium/875%20Koko%20Eating%20Bananas/#keywords","title":"Keywords","text":"<ul> <li>Binary Search</li> </ul>"},{"location":"Medium/875%20Koko%20Eating%20Bananas/#code","title":"Code","text":"<pre><code>func check(mid, h int, piles []int) bool {\n    for _, pile := range piles {\n        if pile &lt;= mid {\n            h -= 1\n        } else {\n            if pile % mid != 0 {\n                h -= 1\n            }\n            h -= (pile / mid)\n        }\n        if h &lt; 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc minEatingSpeed(piles []int, h int) int {\n    maxPile := 0\n    for _, pile := range piles {\n        maxPile = max(maxPile, pile)\n    }\n    l, r := 1, maxPile\n    for l &lt;= r {\n        mid := (l + r) / 2\n        if check(mid, h, piles) {\n            r = mid - 1\n        } else {\n            l = mid + 1\n        }\n    }\n    return l\n}\n</code></pre>"},{"location":"Medium/881%20Boats%20to%20Save%20People/","title":"881. Boats to Save People","text":""},{"location":"Medium/881%20Boats%20to%20Save%20People/#intuition","title":"Intuition","text":"<p>This problem will use two pointer to record the current limit is meet the limit or not and count the total boats we need.</p>"},{"location":"Medium/881%20Boats%20to%20Save%20People/#approach","title":"Approach","text":"<ol> <li>Sort the array of people's weights in ascending order.</li> <li>Use two pointers: one starting from the lightest person (left) and one from the heaviest person (right).</li> <li>For each iteration, try to pair the lightest and heaviest people:<ul> <li>If their combined weight is within the limit, both can share a boat (increment left pointer).</li> <li>If their combined weight exceeds the limit, the heavier person must take a boat alone.</li> </ul> </li> <li>In either case, the right pointer decreases and we count one more boat.</li> <li>Continue until all people are assigned to boats.</li> <li>If there's one person left (when left equals right), allocate one more boat.</li> </ol>"},{"location":"Medium/881%20Boats%20to%20Save%20People/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(NlogN)</li> <li>Space complexity: O(1)</li> </ul>"},{"location":"Medium/881%20Boats%20to%20Save%20People/#keywords","title":"Keywords","text":"<ul> <li>Two Pointers</li> <li>Greedy Algorithm</li> <li>Sorting</li> </ul>"},{"location":"Medium/881%20Boats%20to%20Save%20People/#code","title":"Code","text":"<pre><code>func numRescueBoats(people []int, limit int) int {\n    ret, i, j := 0, 0, len(people) - 1\n    sort.Ints(people)\n\n    for i &lt; j {\n        if people[i] + people[j] &lt;= limit {\n            i += 1\n        }\n        j, ret = j - 1, ret + 1\n    }\n\n    if i == j {\n        ret += 1\n    }\n    return ret\n}\n</code></pre>"},{"location":"Medium/912%20Sort%20an%20Array/","title":"912. Sort an Array","text":""},{"location":"Medium/912%20Sort%20an%20Array/#intuition","title":"Intuition","text":"<p>We can use a counting sort approach with bucket sort, which is efficient for this specific range of numbers.</p>"},{"location":"Medium/912%20Sort%20an%20Array/#approach","title":"Approach","text":"<ol> <li>Create a bucket array of size 100001 (to accommodate numbers from -50000 to 50000)</li> <li>Count the frequency of each number by adding 50000 to the index (to handle negative numbers)</li> <li>Reconstruct the sorted array by iterating through the bucket array and placing numbers back in their original positions</li> </ol>"},{"location":"Medium/912%20Sort%20an%20Array/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(n + k)</li> <li>Space complexity: O(k)</li> </ul>"},{"location":"Medium/912%20Sort%20an%20Array/#keywords","title":"Keywords","text":"<ul> <li>Sorting</li> <li>Counting Sort</li> <li>Bucket Sort</li> </ul>"},{"location":"Medium/912%20Sort%20an%20Array/#code","title":"Code","text":"<pre><code>func sortArray(nums []int) []int {\n    bucket := make([]int, 100001)\n    for _, num := range nums {\n        bucket[num + 50000] += 1\n    }\n    idx := 0\n    for i, cnt := range bucket {\n        for cnt != 0 {\n            nums[idx] = i - 50000\n            idx, cnt = idx + 1, cnt - 1\n        }\n    }\n    return nums\n}\n</code></pre>"},{"location":"Medium/948%20Bag%20Of%20Tokens/","title":"948 Bag Of Tokens","text":""},{"location":"Medium/948%20Bag%20Of%20Tokens/#intuition","title":"Intuition","text":"<p>Get the points by reducing the least power, and use only one points to gain the most power.</p> <p>It's precisely a greedy problem.</p>"},{"location":"Medium/948%20Bag%20Of%20Tokens/#approach","title":"Approach","text":"<p>At first, check whether the length of \"tockens\" is 0. If it is, just return 0.</p> <p>Second, sort the tokens, because I would like to get the least tocken (idx == front) and the most token (idx == back) as soon as possible.</p> <p>For each loop, if power is greater than the least token (idx == 0), get it directly and increase the point. But if there doesn't have enough power, get the most token with decreasing one point.</p> <p>However, for each time you get the point you need to check if it the most points record you get, since it may be decreased by get the most token.</p> <p>Last, return the maximum point you have ever get!</p>"},{"location":"Medium/948%20Bag%20Of%20Tokens/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(NlogN)</li> <li>Space complexity: O(1)</li> </ul>"},{"location":"Medium/948%20Bag%20Of%20Tokens/#keywords","title":"Keywords","text":"<ul> <li>Greedy</li> <li>Sort</li> </ul>"},{"location":"Medium/948%20Bag%20Of%20Tokens/#code","title":"Code","text":"<pre><code>func bagOfTokensScore(tokens []int, power int) int {\n    if len(tokens) == 0 {\n        return 0\n    }\n    maxret, ret := 0, 0\n    sort.Ints(tokens)\n    minT, maxT := 0, len(tokens) - 1\n    for minT &lt;= maxT{\n        if power &gt;= tokens[minT] {\n            power -= tokens[minT]\n            minT += 1\n            ret += 1\n            maxret = max(maxret, ret)\n        } else {\n            if ret &gt; 0 {\n                power += tokens[maxT]\n                maxT -= 1\n                ret -= 1\n            } else {\n                break\n            }\n        }\n    }\n    return maxret\n}\n</code></pre>"}]}